} else {                                    # longleaf
library(pracma, lib.loc = "../rpkgs/")
library(gnorm,  lib.loc = "../rpkgs/")
args <- commandArgs(trailingOnly = TRUE)  # sequence from batch file
idx  <- as.numeric(args[1]);
}
# Model information, including all functions used (The only additional source file to be called is "code_enrollment.R")
load(file = 'args_model.RData') # loads all model information include prior parameters AND SETS SEED
set.seed(idx*92920)  #  05-19-2020
# Simulation information
simulation <- read.csv(file = "args_simulation.csv", header = TRUE, sep = ",")
for(i in 1:ncol(simulation)){
assign(names(simulation)[i], simulation[idx, names(simulation)[i]])
}
# Simulations ---
vars  <- c("y1.IP", "y0.IP", "y1.PC", "y0.PC", "eff.prob", "fut.prob", "eff.mix.prob", "box.skpt", "box.enth", "box.ni")
names <- c(paste(vars, "initial", sep="."), paste(vars, "final",   sep="."))
inner <- array(NA, dim = c(reps, length(names)), dimnames = list(seq_len(reps), names))
for (i in 1:reps){
{print(paste0("IDX ", idx, ", Simulation ", i))}
source("04_code_enrollment.R")
for (j in unique(c(seq(min.ss, max.ss, by = freq.mntr), max.ss))){
#for(j in max.ss){
#{print(paste0("Inner loop: ", j))}
n.initial          <- j
mon.result.initial <- monitoring(index = j)
futility           <- mon.result.initial$fut.prob
efficacy           <- mon.result.initial$eff.prob
if (futility > sig.fut | efficacy > sig.eff){
break
}
}
# Initial
for(k in 1:length(vars)){ inner[i, paste(vars[k], "initial", sep = ".")] <- as.numeric(mon.result.initial[vars[k]]) }
# Final
cutoff.time                      <- outcome.times.all[n.initial]
n.final                          <- sum(enr.times.all <= cutoff.time)
mon.result.final                 <- monitoring(index = n.final) # calls prior_data_conflict(), takes time
for(k in 1:length(vars)){ inner[i, paste(vars[k], "final", sep = ".")] <- as.numeric(mon.result.final[vars[k]]) }
}
Table0     <- data.frame(t(inner))
Table0$idx <- idx
write.csv(Table0, file = paste0("../output/Table0/", idx, "Table0.csv"))
}
monitoring
monitoring
y1.IP
y1.PC
y1.IP <- y1.PC <- y0.IP <- y0.PC <- 25
y1.IP
y1.PC
y0.IP
y0.PC
source("05_code_posteriors.R", local = TRUE)
## efficacy probability using skeptical prior (scaled)
#  integrate joint prior from [delta.skpt, 1], stop if greater than 1 - epsilon
eff.prob.skpt <- integrate_debug(skpt.post.sc.1, xmin = delta.skpt, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
## efficacy probability using enthusiastic prior (scaled)
#  integrate joint prior from [delta.skpt, 1], stop if greater than 1 - epsilon
eff.prob.enth <- integrate_debug(enth.post.sc.1, xmin = delta.skpt, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
## futility probability using skeptical prior (scaled)
# integrate joint prior from [delta.intr , 1], stop if less than epsilon
# alternatively, stop if 1 - (fut.prob.skpt/skpt.nc.sc) is greater than 1 - epsilon
# UPDATE 9/29/20: change xmin from delta.intr to delta.enth
fut.prob.skpt <- integrate_debug(skpt.post.sc.1, xmin = delta.enth, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
# futility probability using enthusiastic prior (scaled)
# integrate joint prior from [delta.intr , 1], stop if less than epsilon
# alternatively, stop if 1 - (fut.prob.skpt/skpt.nc.sc) is greater than 1 - epsilon
# UPDATE 9/29/20: change xmin from delta.intr to delta.enth
fut.prob.enth <- integrate_debug(enth.post.sc.1, xmin = delta.enth, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
# Recall default is eff.skpt.wt <- 1   (all skeptical prior for efficacy monitoring)
eff.prob <- eff.skpt.wt*(eff.prob.skpt/skpt.nc.sc) + (1 - eff.skpt.wt)*(eff.prob.enth/enth.nc.sc)
# Recall default is fut.skpt.wt <- 0   (all enthusiastic prior for futility monitoring)
fut.prob <- fut.skpt.wt*(1 - fut.prob.skpt/skpt.nc.sc) + (1 - fut.skpt.wt)*(1 - fut.prob.enth/enth.nc.sc)
# Recall inference prior is also making a judgement of efficacy
# Recall default is inf.skpt.wt <- 0.5 (50:50 mixture for inference)
inf.prob <- inf.skpt.wt*(eff.prob.skpt/skpt.nc.sc) + (1 - inf.skpt.wt)*(eff.prob.enth/enth.nc.sc)
return(data.frame(cbind(eff.prob, inf.prob, fut.prob, eff.mix.prob, risk.diff.mle, box.skpt, box.enth, box.ni, y1.IP, y1.PC, y0.IP, y0.PC)))
eff.prob
fut.prob
fut.skpt.wt
1-fut.skpt.wt
fut.prob.enth
enth.nc.sc
(1 - fut.skpt.wt)
(1 - fut.prob.enth/enth.nc.sc)
eff.skpt.wt*(eff.prob.skpt/skpt.nc.sc)
(1 - eff.skpt.wt)*(eff.prob.enth/enth.nc.sc)
fut.skpt.wt*(1 - fut.prob.skpt/skpt.nc.sc)
(1 - fut.skpt.wt)*(1 - fut.prob.enth/enth.nc.sc)
y0.IP <- y1.IP <- y0.PC <- y1.PC <- 50
y1.IP <- sum(responses.IP[outcome.times.IP <= outcome.times.all[index]] == 1)
y0.IP <- sum(responses.IP[outcome.times.IP <= outcome.times.all[index]] == 0)
y1.PC <- sum(responses.PC[outcome.times.PC <= outcome.times.all[index]] == 1)
y0.PC <- sum(responses.PC[outcome.times.PC <= outcome.times.all[index]] == 0)
source("05_code_posteriors.R", local = TRUE)
## efficacy probability using skeptical prior (scaled)
#  integrate joint prior from [delta.skpt, 1], stop if greater than 1 - epsilon
eff.prob.skpt <- integrate_debug(skpt.post.sc.1, xmin = delta.skpt, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
## efficacy probability using enthusiastic prior (scaled)
#  integrate joint prior from [delta.skpt, 1], stop if greater than 1 - epsilon
eff.prob.enth <- integrate_debug(enth.post.sc.1, xmin = delta.skpt, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
## futility probability using skeptical prior (scaled)
# integrate joint prior from [delta.intr , 1], stop if less than epsilon
# alternatively, stop if 1 - (fut.prob.skpt/skpt.nc.sc) is greater than 1 - epsilon
# UPDATE 9/29/20: change xmin from delta.intr to delta.enth
fut.prob.skpt <- integrate_debug(skpt.post.sc.1, xmin = delta.enth, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
# futility probability using enthusiastic prior (scaled)
# integrate joint prior from [delta.intr , 1], stop if less than epsilon
# alternatively, stop if 1 - (fut.prob.skpt/skpt.nc.sc) is greater than 1 - epsilon
# UPDATE 9/29/20: change xmin from delta.intr to delta.enth
fut.prob.enth <- integrate_debug(enth.post.sc.1, xmin = delta.enth, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
# Recall default is eff.skpt.wt <- 1   (all skeptical prior for efficacy monitoring)
eff.prob <- eff.skpt.wt*(eff.prob.skpt/skpt.nc.sc) + (1 - eff.skpt.wt)*(eff.prob.enth/enth.nc.sc)
# Recall default is fut.skpt.wt <- 0   (all enthusiastic prior for futility monitoring)
fut.prob <- fut.skpt.wt*(1 - fut.prob.skpt/skpt.nc.sc) + (1 - fut.skpt.wt)*(1 - fut.prob.enth/enth.nc.sc)
# Recall inference prior is also making a judgement of efficacy
# Recall default is inf.skpt.wt <- 0.5 (50:50 mixture for inference)
inf.prob <- inf.skpt.wt*(eff.prob.skpt/skpt.nc.sc) + (1 - inf.skpt.wt)*(eff.prob.enth/enth.nc.sc)
return(data.frame(cbind(eff.prob, inf.prob, fut.prob, eff.mix.prob, risk.diff.mle, box.skpt, box.enth, box.ni, y1.IP, y1.PC, y0.IP, y0.PC)))
fut.prob
eff.prob
y0.IP
y0.PC
y1.PC <- y0.PC <- 50
y1.IP <- 30
y0.IP <- 70
source("05_code_posteriors.R", local = TRUE)
## efficacy probability using skeptical prior (scaled)
#  integrate joint prior from [delta.skpt, 1], stop if greater than 1 - epsilon
eff.prob.skpt <- integrate_debug(skpt.post.sc.1, xmin = delta.skpt, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
## efficacy probability using enthusiastic prior (scaled)
#  integrate joint prior from [delta.skpt, 1], stop if greater than 1 - epsilon
eff.prob.enth <- integrate_debug(enth.post.sc.1, xmin = delta.skpt, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
## futility probability using skeptical prior (scaled)
# integrate joint prior from [delta.intr , 1], stop if less than epsilon
# alternatively, stop if 1 - (fut.prob.skpt/skpt.nc.sc) is greater than 1 - epsilon
# UPDATE 9/29/20: change xmin from delta.intr to delta.enth
fut.prob.skpt <- integrate_debug(skpt.post.sc.1, xmin = delta.enth, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
# futility probability using enthusiastic prior (scaled)
# integrate joint prior from [delta.intr , 1], stop if less than epsilon
# alternatively, stop if 1 - (fut.prob.skpt/skpt.nc.sc) is greater than 1 - epsilon
# UPDATE 9/29/20: change xmin from delta.intr to delta.enth
fut.prob.enth <- integrate_debug(enth.post.sc.1, xmin = delta.enth, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
# Recall default is eff.skpt.wt <- 1   (all skeptical prior for efficacy monitoring)
eff.prob <- eff.skpt.wt*(eff.prob.skpt/skpt.nc.sc) + (1 - eff.skpt.wt)*(eff.prob.enth/enth.nc.sc)
# Recall default is fut.skpt.wt <- 0   (all enthusiastic prior for futility monitoring)
fut.prob <- fut.skpt.wt*(1 - fut.prob.skpt/skpt.nc.sc) + (1 - fut.skpt.wt)*(1 - fut.prob.enth/enth.nc.sc)
# Recall inference prior is also making a judgement of efficacy
# Recall default is inf.skpt.wt <- 0.5 (50:50 mixture for inference)
inf.prob <- inf.skpt.wt*(eff.prob.skpt/skpt.nc.sc) + (1 - inf.skpt.wt)*(eff.prob.enth/enth.nc.sc)
return(data.frame(cbind(eff.prob, inf.prob, fut.prob, eff.mix.prob, risk.diff.mle, box.skpt, box.enth, box.ni, y1.IP, y1.PC, y0.IP, y0.PC)))
eff.prob
fut.prob
monitoring
prior_dat_conflict
monitoring
fut.prob.enth
fut.prob.skpt
(1 - fut.prob.skpt/skpt.nc.sc)
(1 - fut.prob.enth/enth.nc.sc)
y0.IP <- y0.PC <- y1.IP <- y1.PC <- 100
source("05_code_posteriors.R", local = TRUE)
## efficacy probability using skeptical prior (scaled)
#  integrate joint prior from [delta.skpt, 1], stop if greater than 1 - epsilon
eff.prob.skpt <- integrate_debug(skpt.post.sc.1, xmin = delta.skpt, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
## efficacy probability using enthusiastic prior (scaled)
#  integrate joint prior from [delta.skpt, 1], stop if greater than 1 - epsilon
eff.prob.enth <- integrate_debug(enth.post.sc.1, xmin = delta.skpt, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
## futility probability using skeptical prior (scaled)
# integrate joint prior from [delta.intr , 1], stop if less than epsilon
# alternatively, stop if 1 - (fut.prob.skpt/skpt.nc.sc) is greater than 1 - epsilon
# UPDATE 9/29/20: change xmin from delta.intr to delta.enth
fut.prob.skpt <- integrate_debug(skpt.post.sc.1, xmin = delta.enth, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
# futility probability using enthusiastic prior (scaled)
# integrate joint prior from [delta.intr , 1], stop if less than epsilon
# alternatively, stop if 1 - (fut.prob.skpt/skpt.nc.sc) is greater than 1 - epsilon
# UPDATE 9/29/20: change xmin from delta.intr to delta.enth
fut.prob.enth <- integrate_debug(enth.post.sc.1, xmin = delta.enth, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
# Recall default is eff.skpt.wt <- 1   (all skeptical prior for efficacy monitoring)
eff.prob <- eff.skpt.wt*(eff.prob.skpt/skpt.nc.sc) + (1 - eff.skpt.wt)*(eff.prob.enth/enth.nc.sc)
# Recall default is fut.skpt.wt <- 0   (all enthusiastic prior for futility monitoring)
fut.prob <- fut.skpt.wt*(1 - fut.prob.skpt/skpt.nc.sc) + (1 - fut.skpt.wt)*(1 - fut.prob.enth/enth.nc.sc)
# Recall inference prior is also making a judgement of efficacy
# Recall default is inf.skpt.wt <- 0.5 (50:50 mixture for inference)
inf.prob <- inf.skpt.wt*(eff.prob.skpt/skpt.nc.sc) + (1 - inf.skpt.wt)*(eff.prob.enth/enth.nc.sc)
return(data.frame(cbind(eff.prob, inf.prob, fut.prob, eff.mix.prob, risk.diff.mle, box.skpt, box.enth, box.ni, y1.IP, y1.PC, y0.IP, y0.PC)))
inf.prob
fut.prob
eff.prob
delta.skpt
delta.enth
2*delta.enth
2*delta.enth
source("05_code_posteriors.R", local = TRUE)
## efficacy probability using skeptical prior (scaled)
#  integrate joint prior from [delta.skpt, 1], stop if greater than 1 - epsilon
eff.prob.skpt <- integrate_debug(skpt.post.sc.1, xmin = delta.skpt, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
## efficacy probability using enthusiastic prior (scaled)
#  integrate joint prior from [delta.skpt, 1], stop if greater than 1 - epsilon
eff.prob.enth <- integrate_debug(enth.post.sc.1, xmin = delta.skpt, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
## futility probability using skeptical prior (scaled)
# integrate joint prior from [delta.intr , 1], stop if less than epsilon
# alternatively, stop if 1 - (fut.prob.skpt/skpt.nc.sc) is greater than 1 - epsilon
# UPDATE 9/29/20: change xmin from delta.intr to delta.enth
fut.prob.skpt <- integrate_debug(skpt.post.sc.1, xmin = 2*delta.enth, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
# futility probability using enthusiastic prior (scaled)
# integrate joint prior from [delta.intr , 1], stop if less than epsilon
# alternatively, stop if 1 - (fut.prob.skpt/skpt.nc.sc) is greater than 1 - epsilon
# UPDATE 9/29/20: change xmin from delta.intr to delta.enth
fut.prob.enth <- integrate_debug(enth.post.sc.1, xmin = 2*delta.enth, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
# Recall default is eff.skpt.wt <- 1   (all skeptical prior for efficacy monitoring)
eff.prob <- eff.skpt.wt*(eff.prob.skpt/skpt.nc.sc) + (1 - eff.skpt.wt)*(eff.prob.enth/enth.nc.sc)
# Recall default is fut.skpt.wt <- 0   (all enthusiastic prior for futility monitoring)
fut.prob <- fut.skpt.wt*(1 - fut.prob.skpt/skpt.nc.sc) + (1 - fut.skpt.wt)*(1 - fut.prob.enth/enth.nc.sc)
eff.prob
fut.prob
##################################
### Evan Kwiatkowski, Feb 2020
###
### contains nested source("code_posteriors.R", local = TRUE)
###
##################################
# Monitoring ---
monitoring <- function(index){
y1.IP <- sum(responses.IP[outcome.times.IP <= outcome.times.all[index]] == 1)
y0.IP <- sum(responses.IP[outcome.times.IP <= outcome.times.all[index]] == 0)
y1.PC <- sum(responses.PC[outcome.times.PC <= outcome.times.all[index]] == 1)
y0.PC <- sum(responses.PC[outcome.times.PC <= outcome.times.all[index]] == 0)
source("05_code_posteriors.R", local = TRUE)
## efficacy probability using skeptical prior (scaled)
#  integrate joint prior from [delta.skpt, 1], stop if greater than 1 - epsilon
eff.prob.skpt <- integrate_debug(skpt.post.sc.1, xmin = delta.skpt, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
## efficacy probability using enthusiastic prior (scaled)
#  integrate joint prior from [delta.skpt, 1], stop if greater than 1 - epsilon
eff.prob.enth <- integrate_debug(enth.post.sc.1, xmin = delta.skpt, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
## futility probability using skeptical prior (scaled)
# integrate joint prior from [delta.intr , 1], stop if less than epsilon
# alternatively, stop if 1 - (fut.prob.skpt/skpt.nc.sc) is greater than 1 - epsilon
# UPDATE 9/29/20: change xmin from delta.intr to delta.enth
fut.prob.skpt <- integrate_debug(skpt.post.sc.1, xmin = delta.enth, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
# futility probability using enthusiastic prior (scaled)
# integrate joint prior from [delta.intr , 1], stop if less than epsilon
# alternatively, stop if 1 - (fut.prob.skpt/skpt.nc.sc) is greater than 1 - epsilon
# UPDATE 9/29/20: change xmin from delta.intr to delta.enth
fut.prob.enth <- integrate_debug(enth.post.sc.1, xmin = delta.enth, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
# Recall default is eff.skpt.wt <- 1   (all skeptical prior for efficacy monitoring)
eff.prob <- eff.skpt.wt*(eff.prob.skpt/skpt.nc.sc) + (1 - eff.skpt.wt)*(eff.prob.enth/enth.nc.sc)
# Recall default is fut.skpt.wt <- 0   (all enthusiastic prior for futility monitoring)
fut.prob <- fut.skpt.wt*(1 - fut.prob.skpt/skpt.nc.sc) + (1 - fut.skpt.wt)*(1 - fut.prob.enth/enth.nc.sc)
# Recall inference prior is also making a judgement of efficacy
# Recall default is inf.skpt.wt <- 0.5 (50:50 mixture for inference)
inf.prob <- inf.skpt.wt*(eff.prob.skpt/skpt.nc.sc) + (1 - inf.skpt.wt)*(eff.prob.enth/enth.nc.sc)
# bug caught 2/1/20, (1 - fut.prob.skpt)) must be computed before dividing by normalizing constant
# bug caught 2/2/20, 1 - fut.prob.enth/enth.nc.sc NOT (1 - fut.prob.enth)/enth.nc.sc
# bug caught 3/3/20, first term of fut.prob was fut.skpt.wt*((1 - fut.prob.enth/enth.nc.sc)
# should be fut.skpt.wt*((1 - fut.prob.skpt/skpt.nc.sc)
return(data.frame(cbind(eff.prob, inf.prob, fut.prob, eff.mix.prob, risk.diff.mle, box.skpt, box.enth, box.ni, y1.IP, y1.PC, y0.IP, y0.PC)))
}
seq(.39, 0.63, length = 5)
seq(.27, 0.63, length = 7)
#####################################
# Simulation parameters
# Evan Kwiatkowski, Feb 23, 2020
#
# The (fut|eff).mix.prob weights are
# assigned to the SKEPTICAL component
#####################################
rm(list = ls())
simulation1 <- expand.grid(
seq(.27, 0.63, length = 5), # p.IP
.39, # p.PC
2,   # freq.mntr
1,   # enr.shape
4,   # out.mean
0,   # fut.mix.prob
rep(c(seq(1, 0.25, by = -0.25)), 2), # eff.mix.prob
0.5,  # inf.mix.prob
0.05, # cred.tail
100,  # max.ss
70,   # min.ss
100)   # reps
simulation2 <- expand.grid(
seq(.39, 0.63, length = 5), # p.IP
.39, # p.PC
2,   # freq.mntr
1,   # enr.shape
4,   # out.mean
0,   # fut.mix.prob
rep(10,152), # eff.mix.prob
0.5,  # inf.mix.prob
0.05, # cred.tail
100,  # max.ss
70,   # min.ss
132)   # reps
simulation <- rbind(simulation1, simulation2)
names(simulation) <- c(
"p.IP",
"p.PC",
"freq.mntr",
"enr.shape",
"out.mean",
"fut.mix.prob",
"eff.mix.prob",
"inf.mix.prob",
"cred.tail",
"max.ss",
"min.ss",
"reps")
write.csv(x    = simulation, file = "args_simulation.csv")
simulation1
#####################################
# Simulation parameters
# Evan Kwiatkowski, Feb 23, 2020
#
# The (fut|eff).mix.prob weights are
# assigned to the SKEPTICAL component
#####################################
rm(list = ls())
simulation1 <- expand.grid(
seq(.27, 0.63, length = 7), # p.IP
.39, # p.PC
2,   # freq.mntr
1,   # enr.shape
4,   # out.mean
0,   # fut.mix.prob
rep(c(seq(1, 0.25, by = -0.25)), 2), # eff.mix.prob
0.5,  # inf.mix.prob
0.05, # cred.tail
100,  # max.ss
70,   # min.ss
100)   # reps
simulation1
152*132
getwd()
rm(list = ls())
simulation1 <- expand.grid(
.63, # p.IP
.39, # p.PC
2,   # freq.mntr
1,   # enr.shape
4,   # out.mean
0,   # fut.mix.prob
c(1, 0.5, 101, 130), # eff.mix.prob
0.5,  # inf.mix.prob
0.05, # cred.tail
100,  # max.ss
50,   # min.ss
2)   # reps
simulation2 <- expand.grid(
.63, # p.IP
.39, # p.PC
2,   # freq.mntr
1,   # enr.shape
4,   # out.mean
0,   # fut.mix.prob
c(1, 0.5, 101, 130), # eff.mix.prob
0.5,  # inf.mix.prob
0.05, # cred.tail
92,  # max.ss
50,   # min.ss
2)   # reps
simulation <- rbind(simulation1, simulation2)
#
# simulation <- expand.grid(
#   #seq(.27, 0.63, length = 7), # p.IP
#   # .39, # p.PC
#   NA,
#   NA,
#   2,   # freq.mntr
#   1,   # enr.shape
#   4,   # out.mean
#   0,   # fut.mix.prob
#   # c(seq(1, 0, by = -0.05), 10, 20, 21, 22, 23, 24, 30), # eff.mix.prob
#   c(seq(1, 0, by = -0.05), 101:130), # eff.mix.prob
#   0.5,  # inf.mix.prob
#   0.05, # cred.tail
#   92,  # max.ss
#   50,   # min.ss
#   1)   # reps
names(simulation) <- c(
"p.IP",
"p.PC",
"freq.mntr",
"enr.shape",
"out.mean",
"fut.mix.prob",
"eff.mix.prob",
"inf.mix.prob",
"cred.tail",
"max.ss",
"min.ss",
"reps")
write.csv(x    = simulation, file = "args_simulation.csv")
group <- c(sample(c(rep("PC", 4),
rep("IP", 20))),
sample(c(rep("PC", 38),
rep("IP", 38))))
group
0.39
rr <- 2
p1 <- 0.39
rr <- 2
(p1 * rr) / (1 + p1 * (rr - 1))
rr <- 1.5
(p1 * rr) / (1 + p1 * (rr - 1))
rr <- 1.6
(p1 * rr) / (1 + p1 * (rr - 1))
rr <- 1.7
(p1 * rr) / (1 + p1 * (rr - 1))
rr <- 1.65
(p1 * rr) / (1 + p1 * (rr - 1))
rr <- 1.625
(p1 * rr) / (1 + p1 * (rr - 1))
rr <- 1.63
(p1 * rr) / (1 + p1 * (rr - 1))
delta.list <- seq(0, 0.25, by = 0.05)
beta.list <- c(1, 1.3220, 1.7370, 2.3220, 3.3220)
adapt.mat <- expand.grid(delta.list, beta.list)
adapt.mat$id <- 101:130
adapt.mat
seq(0.27,0.63,by = 0.03)
length(seq(0.27,0.63,by = 0.03))
800/13
10000/61
163/4
163*4
163*4/60
5000*4/60
5000/61
simulation <- expand.grid(
seq(0.27,0.63,by = 0.03), # p.IP
.39, # p.PC
2,   # freq.mntr
1,   # enr.shape
4,   # out.mean
0,   # fut.mix.prob
c(rep(115, 61)), # eff.mix.prob
0.5,  # inf.mix.prob
0.05, # cred.tail
100,  # max.ss
50,   # min.ss
2)   # reps
dim(simulation)
#####################################
# Simulation parameters
# Evan Kwiatkowski, Feb 23, 2020
#
# The (fut|eff).mix.prob weights are
# assigned to the SKEPTICAL component
#####################################
# setwd("/Users/kwiatkoe/Documents/Github/Bayesian-Sequential-Monitoring/Real FDA Data Example/MP_FDA_Check/code")
rm(list = ls())
simulation <- expand.grid(
seq(0.27,0.63,by = 0.03), # p.IP
.39, # p.PC
2,   # freq.mntr
1,   # enr.shape
4,   # out.mean
0,   # fut.mix.prob
c(rep(115, 61)), # eff.mix.prob
0.5,  # inf.mix.prob
0.05, # cred.tail
100,  # max.ss
50,   # min.ss
10)   # reps
# simulation2 <- expand.grid(
#  .63, # p.IP
#  .39, # p.PC
#  2,   # freq.mntr
#  1,   # enr.shape
#  4,   # out.mean
#  0,   # fut.mix.prob
#  c(1, 0.5, 101, 130), # eff.mix.prob
#  0.5,  # inf.mix.prob
#  0.05, # cred.tail
#  100,  # max.ss
#  50,   # min.ss
#  2)   # reps
#
# simulation <- rbind(simulation1, simulation2)
#
# simulation <- expand.grid(
#   #seq(.27, 0.63, length = 7), # p.IP
#   # .39, # p.PC
#   NA,
#   NA,
#   2,   # freq.mntr
#   1,   # enr.shape
#   4,   # out.mean
#   0,   # fut.mix.prob
#   # c(seq(1, 0, by = -0.05), 10, 20, 21, 22, 23, 24, 30), # eff.mix.prob
#   c(seq(1, 0, by = -0.05), 101:130), # eff.mix.prob
#   0.5,  # inf.mix.prob
#   0.05, # cred.tail
#   92,  # max.ss
#   50,   # min.ss
#   1)   # reps
names(simulation) <- c(
"p.IP",
"p.PC",
"freq.mntr",
"enr.shape",
"out.mean",
"fut.mix.prob",
"eff.mix.prob",
"inf.mix.prob",
"cred.tail",
"max.ss",
"min.ss",
"reps")
write.csv(x    = simulation, file = "args_simulation.csv")
