rr <- 1.65
(p1 * rr) / (1 + p1 * (rr - 1))
rr <- 1.625
(p1 * rr) / (1 + p1 * (rr - 1))
rr <- 1.63
(p1 * rr) / (1 + p1 * (rr - 1))
delta.list <- seq(0, 0.25, by = 0.05)
beta.list <- c(1, 1.3220, 1.7370, 2.3220, 3.3220)
adapt.mat <- expand.grid(delta.list, beta.list)
adapt.mat$id <- 101:130
adapt.mat
seq(0.27,0.63,by = 0.03)
length(seq(0.27,0.63,by = 0.03))
800/13
10000/61
163/4
163*4
163*4/60
5000*4/60
5000/61
simulation <- expand.grid(
seq(0.27,0.63,by = 0.03), # p.IP
.39, # p.PC
2,   # freq.mntr
1,   # enr.shape
4,   # out.mean
0,   # fut.mix.prob
c(rep(115, 61)), # eff.mix.prob
0.5,  # inf.mix.prob
0.05, # cred.tail
100,  # max.ss
50,   # min.ss
2)   # reps
dim(simulation)
#####################################
# Simulation parameters
# Evan Kwiatkowski, Feb 23, 2020
#
# The (fut|eff).mix.prob weights are
# assigned to the SKEPTICAL component
#####################################
# setwd("/Users/kwiatkoe/Documents/Github/Bayesian-Sequential-Monitoring/Real FDA Data Example/MP_FDA_Check/code")
rm(list = ls())
simulation <- expand.grid(
seq(0.27,0.63,by = 0.03), # p.IP
.39, # p.PC
2,   # freq.mntr
1,   # enr.shape
4,   # out.mean
0,   # fut.mix.prob
c(rep(115, 61)), # eff.mix.prob
0.5,  # inf.mix.prob
0.05, # cred.tail
100,  # max.ss
50,   # min.ss
10)   # reps
# simulation2 <- expand.grid(
#  .63, # p.IP
#  .39, # p.PC
#  2,   # freq.mntr
#  1,   # enr.shape
#  4,   # out.mean
#  0,   # fut.mix.prob
#  c(1, 0.5, 101, 130), # eff.mix.prob
#  0.5,  # inf.mix.prob
#  0.05, # cred.tail
#  100,  # max.ss
#  50,   # min.ss
#  2)   # reps
#
# simulation <- rbind(simulation1, simulation2)
#
# simulation <- expand.grid(
#   #seq(.27, 0.63, length = 7), # p.IP
#   # .39, # p.PC
#   NA,
#   NA,
#   2,   # freq.mntr
#   1,   # enr.shape
#   4,   # out.mean
#   0,   # fut.mix.prob
#   # c(seq(1, 0, by = -0.05), 10, 20, 21, 22, 23, 24, 30), # eff.mix.prob
#   c(seq(1, 0, by = -0.05), 101:130), # eff.mix.prob
#   0.5,  # inf.mix.prob
#   0.05, # cred.tail
#   92,  # max.ss
#   50,   # min.ss
#   1)   # reps
names(simulation) <- c(
"p.IP",
"p.PC",
"freq.mntr",
"enr.shape",
"out.mean",
"fut.mix.prob",
"eff.mix.prob",
"inf.mix.prob",
"cred.tail",
"max.ss",
"min.ss",
"reps")
write.csv(x    = simulation, file = "args_simulation.csv")
delta.list <- seq(0, 0.25, by = 0.05)
beta.list <- c(1, 1.3220, 1.7370, 2.3220, 3.3220)
adapt.mat <- expand.grid(delta.list, beta.list)
adapt.mat$id <- 101:130
head(adapt.mat)
## BEGIN FAKE DATA FOR GRID OUTCOMES ##################
# remember idx variable is available
y0.seq <- 0:42
y1.seq <- 0:58
mat <- expand.grid(y0.seq, y1.seq)
mat <- expand.grid(y0.seq, y1.seq)
idx <- 43
dat <- mat[idx, ]
dat
dat <- mat[idx, ]
idx <- 430
dat <- mat[idx, ]
dat
View(dat)
View(mat)
mat <- expand.grid(y0.seq, y1.seq,100)
y0.seq <- 0:42
y1.seq <- 0:58
mat <- expand.grid(y0.seq, y1.seq,100)
mat <- expand.grid(42, y0.seq, 58, y1.seq, 100)
head(mat)
## BEGIN FAKE DATA FOR GRID OUTCOMES ##################
# remember idx variable is available
y0.seq <- 0:42
y1.seq <- 0:58
mat <- expand.grid(42, y0.seq, 58, y1.seq, 100)
dat <- mat[idx, ]
names(dat) <- c("nObs0", "yObs0", "nObs1", "yObs1", "targOutNum")
idx <- 1E3
dat <- mat[idx, ]
names(dat) <- c("nObs0", "yObs0", "nObs1", "yObs1", "targOutNum")
names(dat)
dat
y1.IP <- dat[dat$targOutNum == index, "yObs1"]
y0.IP <- dat[dat$targOutNum == index, "nObs1"] - dat[dat$targOutNum == index, "yObs1"]
index <- idx
y1.IP <- dat[dat$targOutNum == index, "yObs1"]
y0.IP <- dat[dat$targOutNum == index, "nObs1"] - dat[dat$targOutNum == index, "yObs1"]
y1.PC <- dat[dat$targOutNum == index, "yObs0"]
y0.PC <- dat[dat$targOutNum == index, "nObs0"] - dat[dat$targOutNum == index, "yObs0"]
mat
dat
y1.IP
mat <- expand.grid(42, y0.seq, 58, y1.seq, 100, 100)
names(dat) <- c("nObs0", "yObs0", "nObs1", "yObs1", "targOutNum")
dat
index <- 100
dat
y1.IP <- dat[dat$targOutNum == index, "yObs1"]
y0.IP <- dat[dat$targOutNum == index, "nObs1"] - dat[dat$targOutNum == index, "yObs1"]
y1.PC <- dat[dat$targOutNum == index, "yObs0"]
y0.PC <- dat[dat$targOutNum == index, "nObs0"] - dat[dat$targOutNum == index, "yObs0"]
y1.IP
y1.PC
y0.IP
y0.IP
y1.PC
y0.PC
y0.seq <- 0:42
y1.seq <- 0:58
mat <- expand.grid(42, y0.seq, 58, y1.seq, 100)
y1.IP <- dat[dat$targOutNum == index, "yObs1"]
y0.IP <- dat[dat$targOutNum == index, "nObs1"] - dat[dat$targOutNum == index, "yObs1"]
y1.PC <- dat[dat$targOutNum == index, "yObs0"]
y0.PC <- dat[dat$targOutNum == index, "nObs0"] - dat[dat$targOutNum == index, "yObs0"]
dat <- mat[idx, ]
names(dat) <- c("nObs0", "yObs0", "nObs1", "yObs1", "targOutNum")
dat
idx
#####################################
# Simulation parameters
# Evan Kwiatkowski, Feb 23, 2020
#
# The (fut|eff).mix.prob weights are
# assigned to the SKEPTICAL component
#####################################
# setwd("/Users/kwiatkoe/Documents/Github/Bayesian-Sequential-Monitoring/Real FDA Data Example/MP_FDA_Check/code")
rm(list = ls())
simulation <- expand.grid(
NA, # p.IP
NA, # p.PC
2,   # freq.mntr
1,   # enr.shape
4,   # out.mean
0,   # fut.mix.prob
rep(101, 2537), # eff.mix.prob
# c(rep(103, 114)), # eff.mix.prob
0.5,  # inf.mix.prob
0.05, # cred.tail
100,  # max.ss
100,   # min.ss
1)   # reps
# simulation2 <- expand.grid(
#  .63, # p.IP
#  .39, # p.PC
#  2,   # freq.mntr
#  1,   # enr.shape
#  4,   # out.mean
#  0,   # fut.mix.prob
#  c(1, 0.5, 101, 130), # eff.mix.prob
#  0.5,  # inf.mix.prob
#  0.05, # cred.tail
#  100,  # max.ss
#  50,   # min.ss
#  2)   # reps
#
# simulation <- rbind(simulation1, simulation2)
#
# simulation <- expand.grid(
#   #seq(.27, 0.63, length = 7), # p.IP
#   # .39, # p.PC
#   NA,
#   NA,
#   2,   # freq.mntr
#   1,   # enr.shape
#   4,   # out.mean
#   0,   # fut.mix.prob
#   # c(seq(1, 0, by = -0.05), 10, 20, 21, 22, 23, 24, 30), # eff.mix.prob
#   c(seq(1, 0, by = -0.05), 101:130), # eff.mix.prob
#   0.5,  # inf.mix.prob
#   0.05, # cred.tail
#   92,  # max.ss
#   50,   # min.ss
#   1)   # reps
names(simulation) <- c(
"p.IP",
"p.PC",
"freq.mntr",
"enr.shape",
"out.mean",
"fut.mix.prob",
"eff.mix.prob",
"inf.mix.prob",
"cred.tail",
"max.ss",
"min.ss",
"reps")
write.csv(x    = simulation, file = "args_simulation.csv")
getwd()
##################################
### Risk difference simulations
### Evan Kwiatkowski, Feb 2020
###
### # If changes made to functions then re-run args_model.R
##################################
# setwd("/Users/kwiatkoe/Documents/Github/Bayesian-Sequential-Monitoring/Real FDA Data Example/MP_FDA_Check/code")
for (idx in 1:8){ # check here
if (Sys.getenv("USER") == "kwiatkoe") {
library(pracma)
library(gnorm)
} else {                                    # longleaf
library(pracma, lib.loc = "../rpkgs/")
library(gnorm,  lib.loc = "../rpkgs/")
args <- commandArgs(trailingOnly = TRUE)  # sequence from batch file
idx  <- as.numeric(args[1]);
}
# Model information, including all functions used (The only additional source file to be called is "code_enrollment.R")
load(file = 'args_model.RData') # loads all model information include prior parameters AND SETS SEED
set.seed(as.integer(idx*92920))  #  05-19-2020
# Simulation information
simulation <- read.csv(file = "args_simulation.csv", header = TRUE, sep = ",")
for(i in 1:ncol(simulation)){
assign(names(simulation)[i], simulation[idx, names(simulation)[i]])
}
# Simulations ---
vars  <- c("y1.IP", "y0.IP", "y1.PC", "y0.PC", "eff.prob", "fut.prob", "eff.mix.prob", "box.skpt", "box.enth", "box.ni")
suffix <- unique(c(seq(min.ss, max.ss, by = freq.mntr), max.ss))
final.inf.vars <- c("pm.skpt","pm.enth","pm.ni","pm.rd","pm.50.50","pm.skpt.enth","pm.skpt.enth.ni","pm.skpt.enth.ni.tilde","box.skpt","box.enth","box.ni","y1.IP","y1.PC","y0.IP","y0.PC")
final.inf.suffix <- "f"
names <- c(
# paste(expand.grid(vars,suffix)$Var1, expand.grid(vars,suffix)$Var2, sep = "."), # 06-10-21 added
paste(vars, "initial", sep = "."),
paste(vars, "final",   sep = "."),
paste(final.inf.vars, final.inf.suffix, sep = "."))
inner <- array(NA, dim = c(reps, length(names)), dimnames = list(seq_len(reps), names))
for (i in 1:reps){
{print(paste0("IDX ", idx, ", Simulation ", i, ", eff_mix_prob ", eff.mix.prob))}
source("04_code_enrollment.R")
for (j in unique(c(seq(min.ss, max.ss, by = freq.mntr), max.ss))){
#for(j in max.ss){
#{print(paste0("Inner loop: ", j))}
n.initial          <- j
mon.result.initial <- monitoring(index = j)
futility           <- mon.result.initial$fut.prob
efficacy           <- mon.result.initial$eff.prob
# # 06-10-21 added
# for(k in 1:length(vars)){ inner[i, paste(vars[k], j, sep = ".")] <- as.numeric(mon.result.initial[vars[k]]) }
if (futility > sig.fut | efficacy > sig.eff){
break
}
}
# Initial
for(k in 1:length(vars)){ inner[i, paste(vars[k], "initial", sep = ".")] <- as.numeric(mon.result.initial[vars[k]]) }
# Final
if (is.na(p.IP)){
n.final                          <- dat[dat$targOutNum == n.initial, "nFin"]
} else {
cutoff.time                      <- outcome.times.all[n.initial]
n.final                          <- sum(enr.times.all <= cutoff.time)
}
mon.result.final                 <- monitoring(index = n.final) # calls prior_data_conflict(), takes time
for(k in 1:length(vars)){ inner[i, paste(vars[k], "final", sep = ".")] <- as.numeric(mon.result.final[vars[k]]) }
# inf.result.final                   <- inference(index = n.final)
# for(k in 1:length(final.inf.vars)){ inner[i, paste(final.inf.vars[k], "f", sep = ".")] <- as.numeric(inf.result.final[final.inf.vars[k]]) }
#
}
Table0     <- data.frame(t(inner))
Table0$idx <- idx
write.csv(Table0, file = paste0("../output/Table0/", idx, "Table0.csv"))
}
dat
y1.IP
idx
# Model information, including all functions used (The only additional source file to be called is "code_enrollment.R")
load(file = 'args_model.RData') # loads all model information include prior parameters AND SETS SEED
set.seed(as.integer(idx*92920))  #  05-19-2020
# Simulation information
simulation <- read.csv(file = "args_simulation.csv", header = TRUE, sep = ",")
for(i in 1:ncol(simulation)){
assign(names(simulation)[i], simulation[idx, names(simulation)[i]])
}
# Simulations ---
vars  <- c("y1.IP", "y0.IP", "y1.PC", "y0.PC", "eff.prob", "fut.prob", "eff.mix.prob", "box.skpt", "box.enth", "box.ni")
suffix <- unique(c(seq(min.ss, max.ss, by = freq.mntr), max.ss))
final.inf.vars <- c("pm.skpt","pm.enth","pm.ni","pm.rd","pm.50.50","pm.skpt.enth","pm.skpt.enth.ni","pm.skpt.enth.ni.tilde","box.skpt","box.enth","box.ni","y1.IP","y1.PC","y0.IP","y0.PC")
final.inf.suffix <- "f"
names <- c(
# paste(expand.grid(vars,suffix)$Var1, expand.grid(vars,suffix)$Var2, sep = "."), # 06-10-21 added
paste(vars, "initial", sep = "."),
paste(vars, "final",   sep = "."),
paste(final.inf.vars, final.inf.suffix, sep = "."))
inner <- array(NA, dim = c(reps, length(names)), dimnames = list(seq_len(reps), names))
reps
{print(paste0("IDX ", idx, ", Simulation ", i, ", eff_mix_prob ", eff.mix.prob))}
source("04_code_enrollment.R")
p.IP
p.PC
is.na(p.IP)
## BEGIN FAKE DATA FOR GRID OUTCOMES ##################
# remember idx variable is available
y0.seq <- 0:42
y1.seq <- 0:58
mat <- expand.grid(42, y0.seq, 58, y1.seq, 100)
y1.IP <- dat[dat$targOutNum == index, "yObs1"]
source("04_code_enrollment.R")
for (j in unique(c(seq(min.ss, max.ss, by = freq.mntr), max.ss))){
#for(j in max.ss){
#{print(paste0("Inner loop: ", j))}
n.initial          <- j
mon.result.initial <- monitoring(index = j)
futility           <- mon.result.initial$fut.prob
efficacy           <- mon.result.initial$eff.prob
# # 06-10-21 added
# for(k in 1:length(vars)){ inner[i, paste(vars[k], j, sep = ".")] <- as.numeric(mon.result.initial[vars[k]]) }
if (futility > sig.fut | efficacy > sig.eff){
break
}
}
##################################
### Risk difference simulations
### Evan Kwiatkowski, Feb 2020
###
### # If changes made to functions then re-run args_model.R
##################################
# setwd("/Users/kwiatkoe/Documents/Github/Bayesian-Sequential-Monitoring/Real FDA Data Example/MP_FDA_Check/code")
for (idx in 1:8){ # check here
if (Sys.getenv("USER") == "kwiatkoe") {
library(pracma)
library(gnorm)
} else {                                    # longleaf
library(pracma, lib.loc = "../rpkgs/")
library(gnorm,  lib.loc = "../rpkgs/")
args <- commandArgs(trailingOnly = TRUE)  # sequence from batch file
idx  <- as.numeric(args[1]);
}
# Model information, including all functions used (The only additional source file to be called is "code_enrollment.R")
load(file = 'args_model.RData') # loads all model information include prior parameters AND SETS SEED
set.seed(as.integer(idx*92920))  #  05-19-2020
# Simulation information
simulation <- read.csv(file = "args_simulation.csv", header = TRUE, sep = ",")
for(i in 1:ncol(simulation)){
assign(names(simulation)[i], simulation[idx, names(simulation)[i]])
}
# Simulations ---
vars  <- c("y1.IP", "y0.IP", "y1.PC", "y0.PC", "eff.prob", "fut.prob", "eff.mix.prob", "box.skpt", "box.enth", "box.ni")
suffix <- unique(c(seq(min.ss, max.ss, by = freq.mntr), max.ss))
final.inf.vars <- c("pm.skpt","pm.enth","pm.ni","pm.rd","pm.50.50","pm.skpt.enth","pm.skpt.enth.ni","pm.skpt.enth.ni.tilde","box.skpt","box.enth","box.ni","y1.IP","y1.PC","y0.IP","y0.PC")
final.inf.suffix <- "f"
names <- c(
# paste(expand.grid(vars,suffix)$Var1, expand.grid(vars,suffix)$Var2, sep = "."), # 06-10-21 added
paste(vars, "initial", sep = "."),
paste(vars, "final",   sep = "."),
paste(final.inf.vars, final.inf.suffix, sep = "."))
inner <- array(NA, dim = c(reps, length(names)), dimnames = list(seq_len(reps), names))
for (i in 1:reps){
{print(paste0("IDX ", idx, ", Simulation ", i, ", eff_mix_prob ", eff.mix.prob))}
source("04_code_enrollment.R")
for (j in unique(c(seq(min.ss, max.ss, by = freq.mntr), max.ss))){
#for(j in max.ss){
#{print(paste0("Inner loop: ", j))}
n.initial          <- j
mon.result.initial <- monitoring(index = j)
futility           <- mon.result.initial$fut.prob
efficacy           <- mon.result.initial$eff.prob
# # 06-10-21 added
# for(k in 1:length(vars)){ inner[i, paste(vars[k], j, sep = ".")] <- as.numeric(mon.result.initial[vars[k]]) }
if (futility > sig.fut | efficacy > sig.eff){
break
}
}
# Initial
for(k in 1:length(vars)){ inner[i, paste(vars[k], "initial", sep = ".")] <- as.numeric(mon.result.initial[vars[k]]) }
# Final
if (is.na(p.IP)){
n.final                          <- dat[dat$targOutNum == n.initial, "nFin"]
} else {
cutoff.time                      <- outcome.times.all[n.initial]
n.final                          <- sum(enr.times.all <= cutoff.time)
}
mon.result.final                 <- monitoring(index = n.final) # calls prior_data_conflict(), takes time
for(k in 1:length(vars)){ inner[i, paste(vars[k], "final", sep = ".")] <- as.numeric(mon.result.final[vars[k]]) }
# inf.result.final                   <- inference(index = n.final)
# for(k in 1:length(final.inf.vars)){ inner[i, paste(final.inf.vars[k], "f", sep = ".")] <- as.numeric(inf.result.final[final.inf.vars[k]]) }
#
}
Table0     <- data.frame(t(inner))
Table0$idx <- idx
write.csv(Table0, file = paste0("../output/Table0/", idx, "Table0.csv"))
}
y1.IP
y0.IP
n.final
n.initial
dat[dat$targOutNum == n.initial, "nFin"]
##################################
### Risk difference simulations
### Evan Kwiatkowski, Feb 2020
###
### # If changes made to functions then re-run args_model.R
##################################
# setwd("/Users/kwiatkoe/Documents/Github/Bayesian-Sequential-Monitoring/Real FDA Data Example/MP_FDA_Check/code")
for (idx in 1:8){ # check here
if (Sys.getenv("USER") == "kwiatkoe") {
library(pracma)
library(gnorm)
} else {                                    # longleaf
library(pracma, lib.loc = "../rpkgs/")
library(gnorm,  lib.loc = "../rpkgs/")
args <- commandArgs(trailingOnly = TRUE)  # sequence from batch file
idx  <- as.numeric(args[1]);
}
# Model information, including all functions used (The only additional source file to be called is "code_enrollment.R")
load(file = 'args_model.RData') # loads all model information include prior parameters AND SETS SEED
set.seed(as.integer(idx*92920))  #  05-19-2020
# Simulation information
simulation <- read.csv(file = "args_simulation.csv", header = TRUE, sep = ",")
for(i in 1:ncol(simulation)){
assign(names(simulation)[i], simulation[idx, names(simulation)[i]])
}
# Simulations ---
vars  <- c("y1.IP", "y0.IP", "y1.PC", "y0.PC", "eff.prob", "fut.prob", "eff.mix.prob", "box.skpt", "box.enth", "box.ni")
suffix <- unique(c(seq(min.ss, max.ss, by = freq.mntr), max.ss))
final.inf.vars <- c("pm.skpt","pm.enth","pm.ni","pm.rd","pm.50.50","pm.skpt.enth","pm.skpt.enth.ni","pm.skpt.enth.ni.tilde","box.skpt","box.enth","box.ni","y1.IP","y1.PC","y0.IP","y0.PC")
final.inf.suffix <- "f"
names <- c(
# paste(expand.grid(vars,suffix)$Var1, expand.grid(vars,suffix)$Var2, sep = "."), # 06-10-21 added
paste(vars, "initial", sep = "."),
paste(vars, "final",   sep = "."),
paste(final.inf.vars, final.inf.suffix, sep = "."))
inner <- array(NA, dim = c(reps, length(names)), dimnames = list(seq_len(reps), names))
for (i in 1:reps){
{print(paste0("IDX ", idx, ", Simulation ", i, ", eff_mix_prob ", eff.mix.prob))}
source("04_code_enrollment.R")
for (j in unique(c(seq(min.ss, max.ss, by = freq.mntr), max.ss))){
#for(j in max.ss){
#{print(paste0("Inner loop: ", j))}
n.initial          <- j
mon.result.initial <- monitoring(index = j)
futility           <- mon.result.initial$fut.prob
efficacy           <- mon.result.initial$eff.prob
# # 06-10-21 added
# for(k in 1:length(vars)){ inner[i, paste(vars[k], j, sep = ".")] <- as.numeric(mon.result.initial[vars[k]]) }
if (futility > sig.fut | efficacy > sig.eff){
break
}
}
# Initial
for(k in 1:length(vars)){ inner[i, paste(vars[k], "initial", sep = ".")] <- as.numeric(mon.result.initial[vars[k]]) }
# Final
if (is.na(p.IP)){
n.final                          <- dat[dat$targOutNum == n.initial, "nFin"]
} else {
cutoff.time                      <- outcome.times.all[n.initial]
n.final                          <- sum(enr.times.all <= cutoff.time)
}
mon.result.final                 <- monitoring(index = n.final) # calls prior_data_conflict(), takes time
for(k in 1:length(vars)){ inner[i, paste(vars[k], "final", sep = ".")] <- as.numeric(mon.result.final[vars[k]]) }
# inf.result.final                   <- inference(index = n.final)
# for(k in 1:length(final.inf.vars)){ inner[i, paste(final.inf.vars[k], "f", sep = ".")] <- as.numeric(inf.result.final[final.inf.vars[k]]) }
#
}
Table0     <- data.frame(t(inner))
Table0$idx <- idx
write.csv(Table0, file = paste0("../output/Table0/", idx, "Table0.csv"))
}
