idx  <- as.numeric(args[1]);
}
# Model information, including all functions used (The only additional source file to be called is "code_enrollment.R")
load(file = 'args_model.RData') # loads all model information include prior parameters AND SETS SEED
set.seed(idx*623202)  #  05-19-2020
# Simulation information
simulation <- read.csv(file = "args_simulation.csv", header = TRUE, sep = ",")
for(i in 1:ncol(simulation)){
assign(names(simulation)[i], simulation[idx, names(simulation)[i]])
}
# Simulations ---
names <- c("y1.IP.initial","y1.IP.final",
"y0.IP.initial","y0.IP.final",
"y1.PC.initial","y1.PC.final",
"y0.PC.initial","y0.PC.final",
"eff.prob.initial","eff.prob.final",
"fut.prob.initial","fut.prob.final",
"eff.mix.prob.initial","eff.mix.prob.final",
"box.skpt.initial", "box.skpt.final",
"box.enth.initial", "box.enth.final",
"box.ni.initial",   "box.ni.final")
inner <- array(NA,
dim = c(reps, length(names)),
dimnames = list(seq_len(reps), names))
for (i in 1:reps){
{print(paste0("IDX ", idx, ", Simulation ", i))}
source("04_code_enrollment.R")
for (j in unique(c(seq(min.ss, max.ss, by = freq.mntr), max.ss))){
#for(j in max.ss){
#{print(paste0("Inner loop: ", j))}
mon.result.initial <- monitoring(index = j)
futility           <- mon.result.initial$fut.prob
efficacy           <- mon.result.initial$eff.prob
if (futility > sig.fut | efficacy > sig.eff){
break
}
}
# Initial
n.initial                        <- j
inner[i, "box.skpt.initial"]     <- mon.result.initial$box.skpt
inner[i, "box.enth.initial"]     <- mon.result.initial$box.enth
inner[i, "box.ni.initial"]       <- mon.result.initial$box.ni
inner[i, "eff.mix.prob.initial"] <- mon.result.final$eff.mix.prob
inner[i, "y1.IP.initial"]        <- mon.result.initial$y1.IP
inner[i, "y1.PC.initial"]        <- mon.result.initial$y1.PC
inner[i, "y0.IP.initial"]        <- mon.result.initial$y0.IP
inner[i, "y0.PC.initial"]        <- mon.result.initial$y0.PC
inner[i, "eff.prob.initial"]     <- mon.result.initial$eff.prob
inner[i, "fut.prob.initial"]     <- mon.result.initial$fut.prob
# Final
cutoff.time                      <- outcome.times.all[n.initial]
n.final                          <- sum(enr.times.all <= cutoff.time)
mon.result.final                 <- monitoring(index = n.final) # calls prior_data_conflict(), takes time
inner[i, "box.skpt.final"]       <- mon.result.final$box.skpt
inner[i, "box.enth.final"]       <- mon.result.final$box.enth
inner[i, "box.ni.final"]         <- mon.result.final$box.ni
inner[i, "eff.mix.prob.final"]   <- mon.result.final$eff.mix.prob
inner[i, "y1.IP.final"]          <- mon.result.final$y1.IP
inner[i, "y1.PC.final"]          <- mon.result.final$y1.PC
inner[i, "y0.IP.final"]          <- mon.result.final$y0.IP
inner[i, "y0.PC.final"]          <- mon.result.final$y0.PC
inner[i, "eff.prob.final"]       <- mon.result.final$eff.prob
inner[i, "fut.prob.final"]       <- mon.result.final$fut.prob
}
Table0     <- data.frame(t(inner))
Table0$idx <- idx
write.csv(Table0, file = paste0("../output/Table0/", idx, "Table0.csv"))
}
paste(vars, "initial", sep=".")
# Simulations ---
vars  <- c("y1.IP",
"y0.IP",
"y1.PC",
"y0.PC",
"eff.prob",
"fut.prob",
"eff.mix.prob",
"box.skpt",
"box.enth",
"box.ni")
paste(vars, "initial", sep=".")
names <- c(paste(vars, "initial", sep="."),
paste(vars, "final",   sep="."))
names
##################################
### Risk difference simulations
### Evan Kwiatkowski, Feb 2020
###
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
##################################
for (idx in 1:5){ # check here
if (Sys.getenv("USER") == "kwiatkoe") {
library(pracma)
library(gnorm)
} else {                                    # longleaf
library(pracma, lib.loc = "../rpkgs/")
library(gnorm,  lib.loc = "../rpkgs/")
args <- commandArgs(trailingOnly = TRUE)  # sequence from batch file
idx  <- as.numeric(args[1]);
}
# Model information, including all functions used (The only additional source file to be called is "code_enrollment.R")
load(file = 'args_model.RData') # loads all model information include prior parameters AND SETS SEED
set.seed(idx*623202)  #  05-19-2020
# Simulation information
simulation <- read.csv(file = "args_simulation.csv", header = TRUE, sep = ",")
for(i in 1:ncol(simulation)){
assign(names(simulation)[i], simulation[idx, names(simulation)[i]])
}
# Simulations ---
vars  <- c("y1.IP",
"y0.IP",
"y1.PC",
"y0.PC",
"eff.prob",
"fut.prob",
"eff.mix.prob",
"box.skpt",
"box.enth",
"box.ni")
names <- c(paste(vars, "initial", sep="."),
paste(vars, "final",   sep="."))
inner <- array(NA,
dim = c(reps, length(names)),
dimnames = list(seq_len(reps), names))
for (i in 1:reps){
{print(paste0("IDX ", idx, ", Simulation ", i))}
source("04_code_enrollment.R")
for (j in unique(c(seq(min.ss, max.ss, by = freq.mntr), max.ss))){
#for(j in max.ss){
#{print(paste0("Inner loop: ", j))}
mon.result.initial <- monitoring(index = j)
futility           <- mon.result.initial$fut.prob
efficacy           <- mon.result.initial$eff.prob
if (futility > sig.fut | efficacy > sig.eff){
break
}
}
# Initial
n.initial                        <- j
inner[i, "box.skpt.initial"]     <- mon.result.initial$box.skpt
inner[i, "box.enth.initial"]     <- mon.result.initial$box.enth
inner[i, "box.ni.initial"]       <- mon.result.initial$box.ni
inner[i, "eff.mix.prob.initial"] <- mon.result.final$eff.mix.prob
inner[i, "y1.IP.initial"]        <- mon.result.initial$y1.IP
inner[i, "y1.PC.initial"]        <- mon.result.initial$y1.PC
inner[i, "y0.IP.initial"]        <- mon.result.initial$y0.IP
inner[i, "y0.PC.initial"]        <- mon.result.initial$y0.PC
inner[i, "eff.prob.initial"]     <- mon.result.initial$eff.prob
inner[i, "fut.prob.initial"]     <- mon.result.initial$fut.prob
# Final
cutoff.time                      <- outcome.times.all[n.initial]
n.final                          <- sum(enr.times.all <= cutoff.time)
mon.result.final                 <- monitoring(index = n.final) # calls prior_data_conflict(), takes time
inner[i, "box.skpt.final"]       <- mon.result.final$box.skpt
inner[i, "box.enth.final"]       <- mon.result.final$box.enth
inner[i, "box.ni.final"]         <- mon.result.final$box.ni
inner[i, "eff.mix.prob.final"]   <- mon.result.final$eff.mix.prob
inner[i, "y1.IP.final"]          <- mon.result.final$y1.IP
inner[i, "y1.PC.final"]          <- mon.result.final$y1.PC
inner[i, "y0.IP.final"]          <- mon.result.final$y0.IP
inner[i, "y0.PC.final"]          <- mon.result.final$y0.PC
inner[i, "eff.prob.final"]       <- mon.result.final$eff.prob
inner[i, "fut.prob.final"]       <- mon.result.final$fut.prob
}
Table0     <- data.frame(t(inner))
Table0$idx <- idx
write.csv(Table0, file = paste0("../output/Table0/", idx, "Table0.csv"))
}
length(names)
?assign
inner[1,"box.skpt.initial"]
assign(inner[1, "box.skpt.initial"], 10)
vars[i]
inner[1, paste(vars[i], "initial", sep = "."] <- 10
inner[1, paste(vars[i], "initial", sep = ".")] <- 10
inner[1, paste(vars[i], "initial", sep = ".")]
mon.result.initial[vars[i]]
# Initial
for(i in 1:length(vars)){
inner[1, paste(vars[i], "initial", sep = ".")] <- mon.result.initial[vars[i]]
}
mon.result.initial[vars[i]]
dim(mon.result.initial[vars[i]])
inner[1, paste(vars[i], "initial", sep = ".")]
i
# Initial
for(k in 1:length(vars)){
inner[i, paste(vars[k], "initial", sep = ".")] <- mon.result.initial[vars[k]]
}
k
inner[i, paste(vars[k], "initial", sep = ".")]
paste(vars[k], "initial", sep = ".")
vars
names
inner[i, paste(vars[k], "initial", sep = ".")]
paste(vars[k], "initial", sep = ".")
inner[i, "y1.IP.initial"]
inner[i, "box.skpt.initial"]
inner
names(inner)
inner <- array(NA, dim = c(reps, length(names)), dimnames = list(seq_len(reps), names))
dimnames(inner)
inner[i, "box.skpt.initial"]
inner
i
# Initial
for(k in 1:length(vars)){
inner[i, paste(vars[k], "initial", sep = ".")] <- mon.result.initial[vars[k]]
}
inner[i, paste(vars[k], "initial", sep = ".")] <- mon.result.initial[vars[k]]
k
i
i <- 1
# Initial
for(k in 1:length(vars)){
inner[i, paste(vars[k], "initial", sep = ".")] <- mon.result.initial[vars[k]]
}
i
inner[i, paste(vars[k], "initial", sep = ".")]
k
vars[2]
vars[3]
vars[4]
inner[i, paste(vars[k], "initial", sep = ".")] <-
3
inner[i, paste(vars[k], "initial", sep = ".")]
inner[1, paste(vars[k], "initial", sep = ".")]
paste(vars[k], "initial", sep = ".")
inner[1, "y0.IP.initial"]
inner[1, c("y0.IP.initial")]
inner[1,1]
inner
inner <- array(NA, dim = c(reps, length(names)), dimnames = list(seq_len(reps), names))
inner
i
inner[1, "y0.IP.initial"]
# Initial
for(k in 1:length(vars)){
inner[i, paste(vars[k], "initial", sep = ".")] <- mon.result.initial[vars[k]]
}
inner
inner <- array(NA, dim = c(reps, length(names)), dimnames = list(seq_len(reps), names))
inner[i, "box.skpt.initial"]     <- mon.result.initial$box.skpt
inner[i, "box.enth.initial"]     <- mon.result.initial$box.enth
inner[i, "box.ni.initial"]       <- mon.result.initial$box.ni
inner[i, "eff.mix.prob.initial"] <- mon.result.final$eff.mix.prob
inner[i, "y1.IP.initial"]        <- mon.result.initial$y1.IP
inner[i, "y1.PC.initial"]        <- mon.result.initial$y1.PC
inner[i, "y0.IP.initial"]        <- mon.result.initial$y0.IP
inner[i, "y0.PC.initial"]        <- mon.result.initial$y0.PC
inner[i, "eff.prob.initial"]     <- mon.result.initial$eff.prob
inner[i, "fut.prob.initial"]     <- mon.result.initial$fut.prob
inner
paste(vars[k], "initial", sep = ".")
i
inner[i, "box.skpt.initial"]
inner[i, paste(vars[k], "initial", sep = ".")]
mon.result.initial[vars[k]]
mon.result.initial[vars[k]]
[mon.result.initial[vars[k]]]
mon.result.initial[vars[k]][1]
mon.result.initial[vars[k]][[1]]
inner[i, paste(vars[k], "initial", sep = ".")] <- mon.result.initial[vars[k]][[1]]
# Initial
for(k in 1:length(vars)){
inner[i, paste(vars[k], "initial", sep = ".")] <- mon.result.initial[vars[k]][[1]]
}
mon.result.initial[vars[k]]
as.numeric(mon.result.initial[vars[k]])
# Initial
for(k in 1:length(vars)){
inner[i, paste(vars[k], "initial", sep = ".")] <- as.numeric(mon.result.initial[vars[k]])
}
inner
##################################
### Risk difference simulations
### Evan Kwiatkowski, Feb 2020
###
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
##################################
for (idx in 1:5){ # check here
if (Sys.getenv("USER") == "kwiatkoe") {
library(pracma)
library(gnorm)
} else {                                    # longleaf
library(pracma, lib.loc = "../rpkgs/")
library(gnorm,  lib.loc = "../rpkgs/")
args <- commandArgs(trailingOnly = TRUE)  # sequence from batch file
idx  <- as.numeric(args[1]);
}
# Model information, including all functions used (The only additional source file to be called is "code_enrollment.R")
load(file = 'args_model.RData') # loads all model information include prior parameters AND SETS SEED
set.seed(idx*623202)  #  05-19-2020
# Simulation information
simulation <- read.csv(file = "args_simulation.csv", header = TRUE, sep = ",")
for(i in 1:ncol(simulation)){
assign(names(simulation)[i], simulation[idx, names(simulation)[i]])
}
# Simulations ---
vars  <- c("y1.IP", "y0.IP", "y1.PC", "y0.PC", "eff.prob", "fut.prob", "eff.mix.prob", "box.skpt", "box.enth", "box.ni")
names <- c(paste(vars, "initial", sep="."), paste(vars, "final",   sep="."))
inner <- array(NA, dim = c(reps, length(names)), dimnames = list(seq_len(reps), names))
for (i in 1:reps){
{print(paste0("IDX ", idx, ", Simulation ", i))}
source("04_code_enrollment.R")
for (j in unique(c(seq(min.ss, max.ss, by = freq.mntr), max.ss))){
#for(j in max.ss){
#{print(paste0("Inner loop: ", j))}
n.initial          <- j
mon.result.initial <- monitoring(index = j)
futility           <- mon.result.initial$fut.prob
efficacy           <- mon.result.initial$eff.prob
if (futility > sig.fut | efficacy > sig.eff){
break
}
}
# Initial
for(k in 1:length(vars)){ inner[i, paste(vars[k], "initial", sep = ".")] <- as.numeric(mon.result.initial[vars[k]]) }
# Final
cutoff.time                      <- outcome.times.all[n.initial]
n.final                          <- sum(enr.times.all <= cutoff.time)
mon.result.final                 <- monitoring(index = n.final) # calls prior_data_conflict(), takes time
for(k in 1:length(vars)){ inner[i, paste(vars[k], "final", sep = ".")] <- as.numeric(mon.result.final[vars[k]]) }
}
Table0     <- data.frame(t(inner))
Table0$idx <- idx
write.csv(Table0, file = paste0("../output/Table0/", idx, "Table0.csv"))
}
##################################
# Model parameters
# Evan Kwiatkowski, Jun 22, 2020
##################################
read.tcsv = function(file, header=TRUE, sep=",", ...) {
n = max(count.fields(file, sep=sep), na.rm=TRUE)
x = readLines(file)
.splitvar = function(x, sep, n) {
var = unlist(strsplit(x, split=sep))
length(var) = n
return(var)
}
x = do.call(cbind, lapply(x, .splitvar, sep=sep, n=n))
x = apply(x, 1, paste, collapse=sep)
out = read.csv(text=x, sep=sep, header=header, ...)
return(out)
}
file_list <- list.files(paste0("../output/Table0"))
for (i in 1:length(file_list)){
temp <- read.tcsv(paste0("../output/Table0/", file_list[i]), header = TRUE)
temp$idx <- temp[nrow(temp),2]
temp <- temp[1:(nrow(temp)-1),]
if (i==1) {
final <- temp
} else {
final <- rbind(final,temp)
}
}
args_simulation <- read.csv(file = "args_simulation.csv", header = TRUE, sep = ",")
final           <- final[,-1]
combined        <- merge(args_simulation, final, by.x = "X", by.y = "idx")
write.csv(combined, file = "Table0_merged.csv") # will be used to bring back from longleaf
#####################################
# Simulation parameters
# Evan Kwiatkowski, Feb 23, 2020
#
# The (fut|eff).mix.prob weights are
# assigned to the SKEPTICAL component
#####################################
rm(list = ls())
simulation1 <- expand.grid(
seq(.39, 0.63, length = 5), # p.IP
.39, # p.PC
2,   # freq.mntr
1,   # enr.shape
4,   # out.mean
0,   # fut.mix.prob
rep(c(seq(1, 0.25, by = -0.25)), 2), # eff.mix.prob
0.5,  # inf.mix.prob
0.05, # cred.tail
100,  # max.ss
70,   # min.ss
10000)   # reps
simulation2 <- expand.grid(
seq(.39, 0.63, length = 5), # p.IP
.39, # p.PC
2,   # freq.mntr
1,   # enr.shape
4,   # out.mean
0,   # fut.mix.prob
rep(10,156), # eff.mix.prob
0.5,  # inf.mix.prob
0.05, # cred.tail
100,  # max.ss
70,   # min.ss
65)   # reps
simulation2 <- expand.grid(
seq(.39, 0.63, length = 5), # p.IP
.39, # p.PC
2,   # freq.mntr
1,   # enr.shape
4,   # out.mean
0,   # fut.mix.prob
rep(10,152), # eff.mix.prob
0.5,  # inf.mix.prob
0.05, # cred.tail
100,  # max.ss
70,   # min.ss
65)   # reps
simulation <- rbind(simulation1, simulation2)
20000/152
#####################################
# Simulation parameters
# Evan Kwiatkowski, Feb 23, 2020
#
# The (fut|eff).mix.prob weights are
# assigned to the SKEPTICAL component
#####################################
rm(list = ls())
simulation1 <- expand.grid(
seq(.39, 0.63, length = 5), # p.IP
.39, # p.PC
2,   # freq.mntr
1,   # enr.shape
4,   # out.mean
0,   # fut.mix.prob
rep(c(seq(1, 0.25, by = -0.25)), 2), # eff.mix.prob
0.5,  # inf.mix.prob
0.05, # cred.tail
100,  # max.ss
70,   # min.ss
10000)   # reps
simulation2 <- expand.grid(
seq(.39, 0.63, length = 5), # p.IP
.39, # p.PC
2,   # freq.mntr
1,   # enr.shape
4,   # out.mean
0,   # fut.mix.prob
rep(10,152), # eff.mix.prob
0.5,  # inf.mix.prob
0.05, # cred.tail
100,  # max.ss
70,   # min.ss
132)   # reps
simulation <- rbind(simulation1, simulation2)
summary(simulation)
#####################################
# Simulation parameters
# Evan Kwiatkowski, Feb 23, 2020
#
# The (fut|eff).mix.prob weights are
# assigned to the SKEPTICAL component
#####################################
rm(list = ls())
simulation1 <- expand.grid(
seq(.39, 0.63, length = 5), # p.IP
.39, # p.PC
2,   # freq.mntr
1,   # enr.shape
4,   # out.mean
0,   # fut.mix.prob
rep(c(seq(1, 0.25, by = -0.25)), 2), # eff.mix.prob
0.5,  # inf.mix.prob
0.05, # cred.tail
100,  # max.ss
70,   # min.ss
10000)   # reps
simulation2 <- expand.grid(
seq(.39, 0.63, length = 5), # p.IP
.39, # p.PC
2,   # freq.mntr
1,   # enr.shape
4,   # out.mean
0,   # fut.mix.prob
rep(10,152), # eff.mix.prob
0.5,  # inf.mix.prob
0.05, # cred.tail
100,  # max.ss
70,   # min.ss
132)   # reps
simulation <- rbind(simulation1, simulation2)
names(simulation) <- c(
"p.IP",
"p.PC",
"freq.mntr",
"enr.shape",
"out.mean",
"fut.mix.prob",
"eff.mix.prob",
"inf.mix.prob",
"cred.tail",
"max.ss",
"min.ss",
"reps")
write.csv(x    = simulation, file = "args_simulation.csv")
