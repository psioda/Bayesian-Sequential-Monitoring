write.csv(combined, file = "Table0_merged.csv") # will be used to bring back from longleaf
###########################################################
#### Figure XXXX, Two Arm Sequential Design Properties ####
###########################################################
rm(list = ls())
output_png <- TRUE
root       <- "/Users/kwiatkoe/Documents/GitHub/Bayesian-Sequential-Monitoring/00-paper/FIGURES/riskdiff/code/plots"
setwd(root)
Table0    <- read.csv("../Table0_merged.csv") # CHANGE HERE
#Table0    <- read.csv("../../output/Table0_merged_071620.csv") # CHANGE HERE
#Table0    <- Table0[Table0$eff.mix.prob==10,]                  # CHANGE HERE
Table0    <- within(Table0, rm(X,X.1,box.ni.initial,box.ni.final))
figure9 <- aggregate(. ~ eff.mix.prob + p.IP, data = Table0, mean)
Table0$eff.mix.prob
Table0$p.IP
figure9 <- aggregate(. ~ eff.mix.prob + p.IP, data = Table0, mean)
?aggregate
aggregate(state.x77, list(Region = state.region), mean)
state.x77
names(Table0)
aggregate(state.x77, list(Region = state.region), mean)
aggregate(state.x77, list(Region = state.region), FUN = mean)
aggregate(x = state.x77, list(Region = state.region), FUN = mean)
aggregate(x = state.x77, by = list(Region = state.region), FUN = mean)
aggregate(. ~ eff.mix.prob + p.IP, x = Table0, mean)
aggregate(by=list(eff.mix.prob, p.IP), x = Table0, mean)
names(state.x77)
state.x77
aggregate(. ~ eff.mix.prob + p.IP, data = Table0, mean)
aggregate(by = list(eff.mix.prob), data = Table0, mean)
aggregate(by = list(eff.mix.prob), x = Table0, mean)
aggregate(by = list(eff.mix.prob), x = Table0, mean)
state.region
aggregate(state.x77,
list(Region = state.region,
Cold = state.x77[,"Frost"] > 130),
mean)
aggregate(. ~ Species, data = iris, mean)
iris
head(iris)
aggregate(. ~ Species, data = iris, mean)
aggregate(. ~ eff.mix.prob, data = Table0, mean)
Table0
type(Table0)
?is.df
figure9 <- aggregate(. ~ eff.mix.prob + p.IP, data = data.frame(Table0), mean)
Table0 <- data.frame(Table0)
figure9 <- aggregate(. ~ eff.mix.prob + p.IP, data = data.frame(Table0), mean)
figure9 <- aggregate(. ~ eff.mix.prob + p.IP, data = Table0, mean)
figure9 <- aggregate(. ~ p.IP, data = Table0, mean)
head(Table0)
table(Table0$eff.mix.prob)
table(Table0$p.IP)
table(Table0$p.IP, Table0$eff.mix.prob)
Table0    <- read.csv("../Table0_merged.csv") # CHANGE HERE
Table0    <- within(Table0, rm(X,X.1,box.ni.initial,box.ni.final,box.skpt.initial,box.skpt.final,box.enth.initial,box.enth.final))
figure9 <- aggregate(. ~ eff.mix.prob + p.IP, data = Table0, mean)
figure9
View(figure9)
Table0$efficacy.initial <- (Table0$eff.prob.initial >= 0.975)
Table0$efficacy.final   <- (Table0$eff.prob.final   >= 0.975)
Table0$futility.initial <- (Table0$fut.prob.initial >= 0.975)
Table0$futility.final   <- (Table0$fut.prob.final   >= 0.975)
Table0$inconcl.initial  <- 1 - Table0$efficacy.initial - Table0$futility.initial
Table0$inconcl.final    <- 1 - Table0$efficacy.final   - Table0$futility.final
figure9 <- aggregate(. ~ eff.mix.prob + p.IP, data = Table0, mean)
View(figure9)
##################################
### Evan Kwiatkowski, Feb 2020
###
### contains nested source("code_posteriors.R", local = TRUE)
###
##################################
# Monitoring ---
monitoring <- function(index){
y1.IP <- sum(responses.IP[outcome.times.IP <= outcome.times.all[index]] == 1)
y0.IP <- sum(responses.IP[outcome.times.IP <= outcome.times.all[index]] == 0)
y1.PC <- sum(responses.PC[outcome.times.PC <= outcome.times.all[index]] == 1)
y0.PC <- sum(responses.PC[outcome.times.PC <= outcome.times.all[index]] == 0)
source("05_code_posteriors.R", local = TRUE)
## efficacy probability using skeptical prior (scaled)
#  integrate joint prior from [delta.skpt, 1], stop if greater than 1 - epsilon
eff.prob.skpt <- integrate_debug(skpt.post.sc.1, xmin = delta.skpt, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
## efficacy probability using enthusiastic prior (scaled)
#  integrate joint prior from [delta.skpt, 1], stop if greater than 1 - epsilon
eff.prob.enth <- integrate_debug(enth.post.sc.1, xmin = delta.skpt, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
## futility probability using skeptical prior (scaled)
# integrate joint prior from [delta.intr , 1], stop if less than epsilon
# alternatively, stop if 1 - (fut.prob.skpt/skpt.nc.sc) is greater than 1 - epsilon
# UPDATE 9/29/20: change xmin from delta.intr to delta.enth
fut.prob.skpt <- integrate_debug(skpt.post.sc.1, xmin = delta.enth, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
# futility probability using enthusiastic prior (scaled)
# integrate joint prior from [delta.intr , 1], stop if less than epsilon
# alternatively, stop if 1 - (fut.prob.skpt/skpt.nc.sc) is greater than 1 - epsilon
# UPDATE 9/29/20: change xmin from delta.intr to delta.enth
fut.prob.enth <- integrate_debug(enth.post.sc.1, xmin = delta.enth, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
# Recall default is eff.skpt.wt <- 1   (all skeptical prior for efficacy monitoring)
eff.prob <- eff.skpt.wt*(eff.prob.skpt/skpt.nc.sc) + (1 - eff.skpt.wt)*(eff.prob.enth/enth.nc.sc)
# Recall default is fut.skpt.wt <- 0   (all enthusiastic prior for futility monitoring)
fut.prob <- fut.skpt.wt*(1 - fut.prob.skpt/skpt.nc.sc) + (1 - fut.skpt.wt)*(1 - fut.prob.enth/enth.nc.sc)
# Recall inference prior is also making a judgement of efficacy
# Recall default is inf.skpt.wt <- 0.5 (50:50 mixture for inference)
inf.prob <- inf.skpt.wt*(eff.prob.skpt/skpt.nc.sc) + (1 - inf.skpt.wt)*(eff.prob.enth/enth.nc.sc)
# bug caught 2/1/20, (1 - fut.prob.skpt)) must be computed before dividing by normalizing constant
# bug caught 2/2/20, 1 - fut.prob.enth/enth.nc.sc NOT (1 - fut.prob.enth)/enth.nc.sc
# bug caught 3/3/20, first term of fut.prob was fut.skpt.wt*((1 - fut.prob.enth/enth.nc.sc)
# should be fut.skpt.wt*((1 - fut.prob.skpt/skpt.nc.sc)
return(data.frame(cbind(eff.prob, inf.prob, fut.prob, eff.mix.prob, risk.diff.mle, box.skpt, box.enth, box.ni, y1.IP, y1.PC, y0.IP, y0.PC)))
}
monitoring
monitoring(10,10,10,10)
source("05_code_posteriors.R", local = TRUE)
getwd()
setwd("/Users/kwiatkoe/Documents/GitHub/Bayesian-Sequential-Monitoring/00-paper/FIGURES/riskdiff/code/")
source("05_code_posteriors.R", local = TRUE)
y1.IP <- y1.PC <- y0.IP <- y0.PC <- 20
source("05_code_posteriors.R", local = TRUE)
eff.mix.prob
eff.mix.prob <- 1
source("05_code_posteriors.R", local = TRUE)
##################################
# Model parameters
# Evan Kwiatkowski, Feb 23, 2020
##################################
rm(list = ls())
if (Sys.getenv("USER") == "kwiatkoe") {
library(pracma)
library(gnorm)
setwd("/Users/kwiatkoe/Documents/GitHub/Bayesian-Sequential-Monitoring/00-paper/FIGURES/riskdiff/code")
}
if (.Platform$OS.type == "unix")    {
library(pracma, lib.loc = "../rpkgs/")
library(gnorm,  lib.loc = "../rpkgs/")
}
delta.enth <- 0.12
delta.skpt <- 0
delta.intr <- (delta.skpt+delta.enth)/2
mu         <- 0.39
sig.fut    <- 0.975
sig.eff    <- 0.975
source("03_code_integrate.R")
source("06_code_functions.R") # contains nested source("code_posteriors.R", local = TRUE)
source("priors/03_enth_joint.R")
enth_joint()
source("priors/06_skpt_joint.R")
skpt_joint()
## based on skpt prior -- measures upper tail and upper half
delta.ni.enth <- 0.42   ## new upper
delta.ni.skpt <- 0.06   ## new modal value
delta.ni.intr <- 0.24   ## new halfway point
#delta.ni.enth <- (3*delta.enth-delta.skpt)/2 ## new upper
#delta.ni.skpt <- (delta.skpt+delta.enth)/2   ## new modal value
#delta.ni.intr <- delta.enth                  ## new halfway point
source("priors/09_ni_joint.R")
ni_joint()
save.image(file = 'args_model.RData')
?monitoring
?monitoring
monitoring
##################################
### Risk difference simulations
### Evan Kwiatkowski, Feb 2020
###
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
##################################
for (idx in 1){ # check here
if (Sys.getenv("USER") == "kwiatkoe") {
library(pracma)
library(gnorm)
} else {                                    # longleaf
library(pracma, lib.loc = "../rpkgs/")
library(gnorm,  lib.loc = "../rpkgs/")
args <- commandArgs(trailingOnly = TRUE)  # sequence from batch file
idx  <- as.numeric(args[1]);
}
# Model information, including all functions used (The only additional source file to be called is "code_enrollment.R")
load(file = 'args_model.RData') # loads all model information include prior parameters AND SETS SEED
set.seed(idx*92920)  #  05-19-2020
# Simulation information
simulation <- read.csv(file = "args_simulation.csv", header = TRUE, sep = ",")
for(i in 1:ncol(simulation)){
assign(names(simulation)[i], simulation[idx, names(simulation)[i]])
}
# Simulations ---
vars  <- c("y1.IP", "y0.IP", "y1.PC", "y0.PC", "eff.prob", "fut.prob", "eff.mix.prob", "box.skpt", "box.enth", "box.ni")
names <- c(paste(vars, "initial", sep="."), paste(vars, "final",   sep="."))
inner <- array(NA, dim = c(reps, length(names)), dimnames = list(seq_len(reps), names))
for (i in 1:reps){
{print(paste0("IDX ", idx, ", Simulation ", i))}
source("04_code_enrollment.R")
for (j in unique(c(seq(min.ss, max.ss, by = freq.mntr), max.ss))){
#for(j in max.ss){
#{print(paste0("Inner loop: ", j))}
n.initial          <- j
mon.result.initial <- monitoring(index = j)
futility           <- mon.result.initial$fut.prob
efficacy           <- mon.result.initial$eff.prob
if (futility > sig.fut | efficacy > sig.eff){
break
}
}
# Initial
for(k in 1:length(vars)){ inner[i, paste(vars[k], "initial", sep = ".")] <- as.numeric(mon.result.initial[vars[k]]) }
# Final
cutoff.time                      <- outcome.times.all[n.initial]
n.final                          <- sum(enr.times.all <= cutoff.time)
mon.result.final                 <- monitoring(index = n.final) # calls prior_data_conflict(), takes time
for(k in 1:length(vars)){ inner[i, paste(vars[k], "final", sep = ".")] <- as.numeric(mon.result.final[vars[k]]) }
}
Table0     <- data.frame(t(inner))
Table0$idx <- idx
write.csv(Table0, file = paste0("../output/Table0/", idx, "Table0.csv"))
}
monitoring
monitoring
y1.IP
y1.PC
y1.IP <- y1.PC <- y0.IP <- y0.PC <- 25
y1.IP
y1.PC
y0.IP
y0.PC
source("05_code_posteriors.R", local = TRUE)
## efficacy probability using skeptical prior (scaled)
#  integrate joint prior from [delta.skpt, 1], stop if greater than 1 - epsilon
eff.prob.skpt <- integrate_debug(skpt.post.sc.1, xmin = delta.skpt, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
## efficacy probability using enthusiastic prior (scaled)
#  integrate joint prior from [delta.skpt, 1], stop if greater than 1 - epsilon
eff.prob.enth <- integrate_debug(enth.post.sc.1, xmin = delta.skpt, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
## futility probability using skeptical prior (scaled)
# integrate joint prior from [delta.intr , 1], stop if less than epsilon
# alternatively, stop if 1 - (fut.prob.skpt/skpt.nc.sc) is greater than 1 - epsilon
# UPDATE 9/29/20: change xmin from delta.intr to delta.enth
fut.prob.skpt <- integrate_debug(skpt.post.sc.1, xmin = delta.enth, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
# futility probability using enthusiastic prior (scaled)
# integrate joint prior from [delta.intr , 1], stop if less than epsilon
# alternatively, stop if 1 - (fut.prob.skpt/skpt.nc.sc) is greater than 1 - epsilon
# UPDATE 9/29/20: change xmin from delta.intr to delta.enth
fut.prob.enth <- integrate_debug(enth.post.sc.1, xmin = delta.enth, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
# Recall default is eff.skpt.wt <- 1   (all skeptical prior for efficacy monitoring)
eff.prob <- eff.skpt.wt*(eff.prob.skpt/skpt.nc.sc) + (1 - eff.skpt.wt)*(eff.prob.enth/enth.nc.sc)
# Recall default is fut.skpt.wt <- 0   (all enthusiastic prior for futility monitoring)
fut.prob <- fut.skpt.wt*(1 - fut.prob.skpt/skpt.nc.sc) + (1 - fut.skpt.wt)*(1 - fut.prob.enth/enth.nc.sc)
# Recall inference prior is also making a judgement of efficacy
# Recall default is inf.skpt.wt <- 0.5 (50:50 mixture for inference)
inf.prob <- inf.skpt.wt*(eff.prob.skpt/skpt.nc.sc) + (1 - inf.skpt.wt)*(eff.prob.enth/enth.nc.sc)
return(data.frame(cbind(eff.prob, inf.prob, fut.prob, eff.mix.prob, risk.diff.mle, box.skpt, box.enth, box.ni, y1.IP, y1.PC, y0.IP, y0.PC)))
eff.prob
fut.prob
fut.skpt.wt
1-fut.skpt.wt
fut.prob.enth
enth.nc.sc
(1 - fut.skpt.wt)
(1 - fut.prob.enth/enth.nc.sc)
eff.skpt.wt*(eff.prob.skpt/skpt.nc.sc)
(1 - eff.skpt.wt)*(eff.prob.enth/enth.nc.sc)
fut.skpt.wt*(1 - fut.prob.skpt/skpt.nc.sc)
(1 - fut.skpt.wt)*(1 - fut.prob.enth/enth.nc.sc)
y0.IP <- y1.IP <- y0.PC <- y1.PC <- 50
y1.IP <- sum(responses.IP[outcome.times.IP <= outcome.times.all[index]] == 1)
y0.IP <- sum(responses.IP[outcome.times.IP <= outcome.times.all[index]] == 0)
y1.PC <- sum(responses.PC[outcome.times.PC <= outcome.times.all[index]] == 1)
y0.PC <- sum(responses.PC[outcome.times.PC <= outcome.times.all[index]] == 0)
source("05_code_posteriors.R", local = TRUE)
## efficacy probability using skeptical prior (scaled)
#  integrate joint prior from [delta.skpt, 1], stop if greater than 1 - epsilon
eff.prob.skpt <- integrate_debug(skpt.post.sc.1, xmin = delta.skpt, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
## efficacy probability using enthusiastic prior (scaled)
#  integrate joint prior from [delta.skpt, 1], stop if greater than 1 - epsilon
eff.prob.enth <- integrate_debug(enth.post.sc.1, xmin = delta.skpt, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
## futility probability using skeptical prior (scaled)
# integrate joint prior from [delta.intr , 1], stop if less than epsilon
# alternatively, stop if 1 - (fut.prob.skpt/skpt.nc.sc) is greater than 1 - epsilon
# UPDATE 9/29/20: change xmin from delta.intr to delta.enth
fut.prob.skpt <- integrate_debug(skpt.post.sc.1, xmin = delta.enth, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
# futility probability using enthusiastic prior (scaled)
# integrate joint prior from [delta.intr , 1], stop if less than epsilon
# alternatively, stop if 1 - (fut.prob.skpt/skpt.nc.sc) is greater than 1 - epsilon
# UPDATE 9/29/20: change xmin from delta.intr to delta.enth
fut.prob.enth <- integrate_debug(enth.post.sc.1, xmin = delta.enth, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
# Recall default is eff.skpt.wt <- 1   (all skeptical prior for efficacy monitoring)
eff.prob <- eff.skpt.wt*(eff.prob.skpt/skpt.nc.sc) + (1 - eff.skpt.wt)*(eff.prob.enth/enth.nc.sc)
# Recall default is fut.skpt.wt <- 0   (all enthusiastic prior for futility monitoring)
fut.prob <- fut.skpt.wt*(1 - fut.prob.skpt/skpt.nc.sc) + (1 - fut.skpt.wt)*(1 - fut.prob.enth/enth.nc.sc)
# Recall inference prior is also making a judgement of efficacy
# Recall default is inf.skpt.wt <- 0.5 (50:50 mixture for inference)
inf.prob <- inf.skpt.wt*(eff.prob.skpt/skpt.nc.sc) + (1 - inf.skpt.wt)*(eff.prob.enth/enth.nc.sc)
return(data.frame(cbind(eff.prob, inf.prob, fut.prob, eff.mix.prob, risk.diff.mle, box.skpt, box.enth, box.ni, y1.IP, y1.PC, y0.IP, y0.PC)))
fut.prob
eff.prob
y0.IP
y0.PC
y1.PC <- y0.PC <- 50
y1.IP <- 30
y0.IP <- 70
source("05_code_posteriors.R", local = TRUE)
## efficacy probability using skeptical prior (scaled)
#  integrate joint prior from [delta.skpt, 1], stop if greater than 1 - epsilon
eff.prob.skpt <- integrate_debug(skpt.post.sc.1, xmin = delta.skpt, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
## efficacy probability using enthusiastic prior (scaled)
#  integrate joint prior from [delta.skpt, 1], stop if greater than 1 - epsilon
eff.prob.enth <- integrate_debug(enth.post.sc.1, xmin = delta.skpt, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
## futility probability using skeptical prior (scaled)
# integrate joint prior from [delta.intr , 1], stop if less than epsilon
# alternatively, stop if 1 - (fut.prob.skpt/skpt.nc.sc) is greater than 1 - epsilon
# UPDATE 9/29/20: change xmin from delta.intr to delta.enth
fut.prob.skpt <- integrate_debug(skpt.post.sc.1, xmin = delta.enth, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
# futility probability using enthusiastic prior (scaled)
# integrate joint prior from [delta.intr , 1], stop if less than epsilon
# alternatively, stop if 1 - (fut.prob.skpt/skpt.nc.sc) is greater than 1 - epsilon
# UPDATE 9/29/20: change xmin from delta.intr to delta.enth
fut.prob.enth <- integrate_debug(enth.post.sc.1, xmin = delta.enth, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
# Recall default is eff.skpt.wt <- 1   (all skeptical prior for efficacy monitoring)
eff.prob <- eff.skpt.wt*(eff.prob.skpt/skpt.nc.sc) + (1 - eff.skpt.wt)*(eff.prob.enth/enth.nc.sc)
# Recall default is fut.skpt.wt <- 0   (all enthusiastic prior for futility monitoring)
fut.prob <- fut.skpt.wt*(1 - fut.prob.skpt/skpt.nc.sc) + (1 - fut.skpt.wt)*(1 - fut.prob.enth/enth.nc.sc)
# Recall inference prior is also making a judgement of efficacy
# Recall default is inf.skpt.wt <- 0.5 (50:50 mixture for inference)
inf.prob <- inf.skpt.wt*(eff.prob.skpt/skpt.nc.sc) + (1 - inf.skpt.wt)*(eff.prob.enth/enth.nc.sc)
return(data.frame(cbind(eff.prob, inf.prob, fut.prob, eff.mix.prob, risk.diff.mle, box.skpt, box.enth, box.ni, y1.IP, y1.PC, y0.IP, y0.PC)))
eff.prob
fut.prob
monitoring
prior_dat_conflict
monitoring
fut.prob.enth
fut.prob.skpt
(1 - fut.prob.skpt/skpt.nc.sc)
(1 - fut.prob.enth/enth.nc.sc)
y0.IP <- y0.PC <- y1.IP <- y1.PC <- 100
source("05_code_posteriors.R", local = TRUE)
## efficacy probability using skeptical prior (scaled)
#  integrate joint prior from [delta.skpt, 1], stop if greater than 1 - epsilon
eff.prob.skpt <- integrate_debug(skpt.post.sc.1, xmin = delta.skpt, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
## efficacy probability using enthusiastic prior (scaled)
#  integrate joint prior from [delta.skpt, 1], stop if greater than 1 - epsilon
eff.prob.enth <- integrate_debug(enth.post.sc.1, xmin = delta.skpt, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
## futility probability using skeptical prior (scaled)
# integrate joint prior from [delta.intr , 1], stop if less than epsilon
# alternatively, stop if 1 - (fut.prob.skpt/skpt.nc.sc) is greater than 1 - epsilon
# UPDATE 9/29/20: change xmin from delta.intr to delta.enth
fut.prob.skpt <- integrate_debug(skpt.post.sc.1, xmin = delta.enth, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
# futility probability using enthusiastic prior (scaled)
# integrate joint prior from [delta.intr , 1], stop if less than epsilon
# alternatively, stop if 1 - (fut.prob.skpt/skpt.nc.sc) is greater than 1 - epsilon
# UPDATE 9/29/20: change xmin from delta.intr to delta.enth
fut.prob.enth <- integrate_debug(enth.post.sc.1, xmin = delta.enth, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
# Recall default is eff.skpt.wt <- 1   (all skeptical prior for efficacy monitoring)
eff.prob <- eff.skpt.wt*(eff.prob.skpt/skpt.nc.sc) + (1 - eff.skpt.wt)*(eff.prob.enth/enth.nc.sc)
# Recall default is fut.skpt.wt <- 0   (all enthusiastic prior for futility monitoring)
fut.prob <- fut.skpt.wt*(1 - fut.prob.skpt/skpt.nc.sc) + (1 - fut.skpt.wt)*(1 - fut.prob.enth/enth.nc.sc)
# Recall inference prior is also making a judgement of efficacy
# Recall default is inf.skpt.wt <- 0.5 (50:50 mixture for inference)
inf.prob <- inf.skpt.wt*(eff.prob.skpt/skpt.nc.sc) + (1 - inf.skpt.wt)*(eff.prob.enth/enth.nc.sc)
return(data.frame(cbind(eff.prob, inf.prob, fut.prob, eff.mix.prob, risk.diff.mle, box.skpt, box.enth, box.ni, y1.IP, y1.PC, y0.IP, y0.PC)))
inf.prob
fut.prob
eff.prob
delta.skpt
delta.enth
2*delta.enth
2*delta.enth
source("05_code_posteriors.R", local = TRUE)
## efficacy probability using skeptical prior (scaled)
#  integrate joint prior from [delta.skpt, 1], stop if greater than 1 - epsilon
eff.prob.skpt <- integrate_debug(skpt.post.sc.1, xmin = delta.skpt, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
## efficacy probability using enthusiastic prior (scaled)
#  integrate joint prior from [delta.skpt, 1], stop if greater than 1 - epsilon
eff.prob.enth <- integrate_debug(enth.post.sc.1, xmin = delta.skpt, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
## futility probability using skeptical prior (scaled)
# integrate joint prior from [delta.intr , 1], stop if less than epsilon
# alternatively, stop if 1 - (fut.prob.skpt/skpt.nc.sc) is greater than 1 - epsilon
# UPDATE 9/29/20: change xmin from delta.intr to delta.enth
fut.prob.skpt <- integrate_debug(skpt.post.sc.1, xmin = 2*delta.enth, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
# futility probability using enthusiastic prior (scaled)
# integrate joint prior from [delta.intr , 1], stop if less than epsilon
# alternatively, stop if 1 - (fut.prob.skpt/skpt.nc.sc) is greater than 1 - epsilon
# UPDATE 9/29/20: change xmin from delta.intr to delta.enth
fut.prob.enth <- integrate_debug(enth.post.sc.1, xmin = 2*delta.enth, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
# Recall default is eff.skpt.wt <- 1   (all skeptical prior for efficacy monitoring)
eff.prob <- eff.skpt.wt*(eff.prob.skpt/skpt.nc.sc) + (1 - eff.skpt.wt)*(eff.prob.enth/enth.nc.sc)
# Recall default is fut.skpt.wt <- 0   (all enthusiastic prior for futility monitoring)
fut.prob <- fut.skpt.wt*(1 - fut.prob.skpt/skpt.nc.sc) + (1 - fut.skpt.wt)*(1 - fut.prob.enth/enth.nc.sc)
eff.prob
fut.prob
##################################
### Evan Kwiatkowski, Feb 2020
###
### contains nested source("code_posteriors.R", local = TRUE)
###
##################################
# Monitoring ---
monitoring <- function(index){
y1.IP <- sum(responses.IP[outcome.times.IP <= outcome.times.all[index]] == 1)
y0.IP <- sum(responses.IP[outcome.times.IP <= outcome.times.all[index]] == 0)
y1.PC <- sum(responses.PC[outcome.times.PC <= outcome.times.all[index]] == 1)
y0.PC <- sum(responses.PC[outcome.times.PC <= outcome.times.all[index]] == 0)
source("05_code_posteriors.R", local = TRUE)
## efficacy probability using skeptical prior (scaled)
#  integrate joint prior from [delta.skpt, 1], stop if greater than 1 - epsilon
eff.prob.skpt <- integrate_debug(skpt.post.sc.1, xmin = delta.skpt, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
## efficacy probability using enthusiastic prior (scaled)
#  integrate joint prior from [delta.skpt, 1], stop if greater than 1 - epsilon
eff.prob.enth <- integrate_debug(enth.post.sc.1, xmin = delta.skpt, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
## futility probability using skeptical prior (scaled)
# integrate joint prior from [delta.intr , 1], stop if less than epsilon
# alternatively, stop if 1 - (fut.prob.skpt/skpt.nc.sc) is greater than 1 - epsilon
# UPDATE 9/29/20: change xmin from delta.intr to delta.enth
fut.prob.skpt <- integrate_debug(skpt.post.sc.1, xmin = delta.enth, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
# futility probability using enthusiastic prior (scaled)
# integrate joint prior from [delta.intr , 1], stop if less than epsilon
# alternatively, stop if 1 - (fut.prob.skpt/skpt.nc.sc) is greater than 1 - epsilon
# UPDATE 9/29/20: change xmin from delta.intr to delta.enth
fut.prob.enth <- integrate_debug(enth.post.sc.1, xmin = delta.enth, xmax = 1, ymin = 0, ymax = function(x) 1 - x)
# Recall default is eff.skpt.wt <- 1   (all skeptical prior for efficacy monitoring)
eff.prob <- eff.skpt.wt*(eff.prob.skpt/skpt.nc.sc) + (1 - eff.skpt.wt)*(eff.prob.enth/enth.nc.sc)
# Recall default is fut.skpt.wt <- 0   (all enthusiastic prior for futility monitoring)
fut.prob <- fut.skpt.wt*(1 - fut.prob.skpt/skpt.nc.sc) + (1 - fut.skpt.wt)*(1 - fut.prob.enth/enth.nc.sc)
# Recall inference prior is also making a judgement of efficacy
# Recall default is inf.skpt.wt <- 0.5 (50:50 mixture for inference)
inf.prob <- inf.skpt.wt*(eff.prob.skpt/skpt.nc.sc) + (1 - inf.skpt.wt)*(eff.prob.enth/enth.nc.sc)
# bug caught 2/1/20, (1 - fut.prob.skpt)) must be computed before dividing by normalizing constant
# bug caught 2/2/20, 1 - fut.prob.enth/enth.nc.sc NOT (1 - fut.prob.enth)/enth.nc.sc
# bug caught 3/3/20, first term of fut.prob was fut.skpt.wt*((1 - fut.prob.enth/enth.nc.sc)
# should be fut.skpt.wt*((1 - fut.prob.skpt/skpt.nc.sc)
return(data.frame(cbind(eff.prob, inf.prob, fut.prob, eff.mix.prob, risk.diff.mle, box.skpt, box.enth, box.ni, y1.IP, y1.PC, y0.IP, y0.PC)))
}
seq(.39, 0.63, length = 5)
seq(.27, 0.63, length = 7)
#####################################
# Simulation parameters
# Evan Kwiatkowski, Feb 23, 2020
#
# The (fut|eff).mix.prob weights are
# assigned to the SKEPTICAL component
#####################################
rm(list = ls())
simulation1 <- expand.grid(
seq(.27, 0.63, length = 5), # p.IP
.39, # p.PC
2,   # freq.mntr
1,   # enr.shape
4,   # out.mean
0,   # fut.mix.prob
rep(c(seq(1, 0.25, by = -0.25)), 2), # eff.mix.prob
0.5,  # inf.mix.prob
0.05, # cred.tail
100,  # max.ss
70,   # min.ss
100)   # reps
simulation2 <- expand.grid(
seq(.39, 0.63, length = 5), # p.IP
.39, # p.PC
2,   # freq.mntr
1,   # enr.shape
4,   # out.mean
0,   # fut.mix.prob
rep(10,152), # eff.mix.prob
0.5,  # inf.mix.prob
0.05, # cred.tail
100,  # max.ss
70,   # min.ss
132)   # reps
simulation <- rbind(simulation1, simulation2)
names(simulation) <- c(
"p.IP",
"p.PC",
"freq.mntr",
"enr.shape",
"out.mean",
"fut.mix.prob",
"eff.mix.prob",
"inf.mix.prob",
"cred.tail",
"max.ss",
"min.ss",
"reps")
write.csv(x    = simulation, file = "args_simulation.csv")
simulation1
#####################################
# Simulation parameters
# Evan Kwiatkowski, Feb 23, 2020
#
# The (fut|eff).mix.prob weights are
# assigned to the SKEPTICAL component
#####################################
rm(list = ls())
simulation1 <- expand.grid(
seq(.27, 0.63, length = 7), # p.IP
.39, # p.PC
2,   # freq.mntr
1,   # enr.shape
4,   # out.mean
0,   # fut.mix.prob
rep(c(seq(1, 0.25, by = -0.25)), 2), # eff.mix.prob
0.5,  # inf.mix.prob
0.05, # cred.tail
100,  # max.ss
70,   # min.ss
100)   # reps
simulation1
152*132
