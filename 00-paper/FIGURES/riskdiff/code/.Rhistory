# n.final                          <- sum(enr.times.all <= cutoff.time)
# mon.result.final                 <- monitoring(index = n.final) # calls prior_data_conflict(), takes time
# futility.final                   <- mon.result.final$fut.prob
# efficacy.final                   <- mon.result.final$eff.prob
# inner[i, "fut.mon.final"]        <- (futility.final > sig.fut)
# inner[i, "eff.mon.final"]        <- (efficacy.final > sig.eff)
# inner[i, "eff.mix.prob"]         <- mon.result.final$eff.mix.prob
# pm.cp.result.final               <- pm_cp(index = n.final) # calls prior_data_conflict(), takes time
# inner[i, "post.mean.final.PC"]   <- pm.cp.result.final$pm.mean.x
# inner[i, "post.mean.final.IP"]   <- pm.cp.result.final$pm.mean.y
# inner[i, "cov.final"]            <- pm.cp.result.final$coverage
# inner[i, "mle.final.PC"]         <- pm.cp.result.final$mle.PC
# inner[i, "mle.final.IP"]         <- pm.cp.result.final$mle.IP
# inner[i, "ss.final"]             <- n.final
# inner[i, "final.p"]              <- efficacy.final
# inner[i, "risk.diff.final"]      <- mon.result.final$risk.diff.mle
# inner[i, "box.skpt.final"]       <- mon.result.final$skpt.psi
# inner[i, "box.enth.final"]       <- mon.result.final$enth.psi
# inner[i, "box.ni.final"]         <- mon.result.final$ni.psi
}
Table0     <- data.frame(t(inner))
Table0$idx <- idx
write.csv(Table0, file = paste0("../output/Table0/", idx, "Table0.csv"))
}
inner
#####################################
# Simulation parameters
# Evan Kwiatkowski, Feb 23, 2020
#
# The (fut|eff).mix.prob weights are
# assigned to the SKEPTICAL component
#####################################
rm(list = ls())
# simulation1 <- expand.grid(
#   seq(.39, 0.63, length = 5), # p.IP
#   .39, # p.PC
#   2,   # freq.mntr
#   1,   # enr.shape
#   4,   # out.mean
#   0,   # fut.mix.prob
#   c(seq(1, 0.25, by = -0.25)), # eff.mix.prob
#   0.5,  # inf.mix.prob
#   0.05, # cred.tail
#   100,  # max.ss
#   70,   # min.ss
#   10000)   # reps
#
# simulation2 <- expand.grid(
#   seq(.39, 0.63, length = 5), # p.IP
#   .39, # p.PC
#   2,   # freq.mntr
#   1,   # enr.shape
#   4,   # out.mean
#   0,   # fut.mix.prob
#   rep(10,156), # eff.mix.prob
#   0.5,  # inf.mix.prob
#   0.05, # cred.tail
#   100,  # max.ss
#   70,   # min.ss
#   65)   # reps
#
# simulation <- rbind(simulation1, simulation2)
# simulation1 <- expand.grid(
#   seq(.39, 0.63, length = 5), # p.IP
#   .39, # p.PC
#   2,   # freq.mntr
#   1,   # enr.shape
#   4,   # out.mean
#   0,   # fut.mix.prob
#   c(seq(1, 0.25, by = -0.25)), # eff.mix.prob
#   0.5,  # inf.mix.prob
#   0.05, # cred.tail
#   100,  # max.ss
#   70,   # min.ss
#   1)   # reps
simulation2 <- expand.grid(
seq(.39, 0.63, length = 5), # p.IP
.39, # p.PC
30,   # freq.mntr
1,   # enr.shape
4,   # out.mean
0,   # fut.mix.prob
10, # eff.mix.prob
0.5,  # inf.mix.prob
0.05, # cred.tail
100,  # max.ss
70,   # min.ss
10)   # reps
simulation <- rbind(simulation2)
names(simulation) <- c(
"p.IP",
"p.PC",
"freq.mntr",
"enr.shape",
"out.mean",
"fut.mix.prob",
"eff.mix.prob",
"inf.mix.prob",
"cred.tail",
"max.ss",
"min.ss",
"reps")
write.csv(x    = simulation, file = "args_simulation.csv")
##################################
### Risk difference simulations
### Evan Kwiatkowski, Feb 2020
###
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
##################################
for (idx in 1:1){ # check here
if (Sys.getenv("USER") == "kwiatkoe") {
library(pracma)
library(gnorm)
} else {                                    # longleaf
library(pracma, lib.loc = "../rpkgs/")
library(gnorm,  lib.loc = "../rpkgs/")
args <- commandArgs(trailingOnly = TRUE)  # sequence from batch file
idx  <- as.numeric(args[1]);
}
# Model information, including all functions used (The only additional source file to be called is "code_enrollment.R")
load(file = 'args_model.RData') # loads all model information include prior parameters AND SETS SEED
set.seed(idx*623202)  #  05-19-2020
# Simulation information
simulation <- read.csv(file = "args_simulation.csv", header = TRUE, sep = ",")
for(i in 1:ncol(simulation)){
assign(names(simulation)[i], simulation[idx, names(simulation)[i]])
}
# Simulations ---
names <- c("eff.mon.initial","eff.mon.final","fut.mon.initial","fut.mon.final",
"ss.initial","ss.final",
"mle.initial.IP","mle.final.IP","mle.initial.PC","mle.final.PC",
"post.mean.initial.IP","post.mean.final.IP","post.mean.initial.PC","post.mean.final.PC",
"cov.initial","cov.final",
"eff.mix.prob",
"initial.p", "final.p",
"box.skpt.initial", "box.skpt.final",
"box.enth.initial", "box.enth.final",
"box.ni.initial",   "box.ni.final",
"risk.diff.initial", "risk.diff.final")
inner <- array(NA,
dim = c(reps, length(names)),
dimnames = list(seq_len(reps), names))
for (i in 1:reps){
{print(paste0("IDX ", idx, ", Simulation ", i))}
source("04_code_enrollment.R")
#for (j in unique(c(seq(min.ss, max.ss, by = freq.mntr), max.ss))){
for(j in max.ss){
#{print(paste0("Inner loop: ", j))}
mon.result.initial <- monitoring(index = j)
futility           <- mon.result.initial$fut.prob
efficacy           <- mon.result.initial$eff.prob
if (futility > sig.fut | efficacy > sig.eff){
break
}
}
# Initial
n.initial                        <- j
inner[i, "fut.mon.initial"]      <- (futility > sig.fut)
inner[i, "eff.mon.initial"]      <- (efficacy > sig.eff)
# pm.cp.result.initial             <- pm_cp(index = n.initial) # calls prior_data_conflict(), takes time
# inner[i, "post.mean.initial.PC"] <- pm.cp.result.initial$pm.mean.x
# inner[i, "post.mean.initial.IP"] <- pm.cp.result.initial$pm.mean.y
# inner[i, "mle.initial.PC"]       <- pm.cp.result.initial$mle.PC
# inner[i, "mle.initial.IP"]       <- pm.cp.result.initial$mle.IP
# inner[i, "cov.initial"]          <- pm.cp.result.initial$coverage
inner[i, "ss.initial"]           <- n.initial
inner[i, "initial.p"]            <- efficacy
inner[i, "risk.diff.initial"]    <- mon.result.initial$risk.diff.mle
inner[i, "box.skpt.initial"]     <- mon.result.initial$skpt.psi
inner[i, "box.enth.initial"]     <- mon.result.initial$enth.psi
inner[i, "box.ni.initial"]       <- mon.result.initial$ni.psi
# # Final ---
# cutoff.time                      <- outcome.times.all[n.initial]
# n.final                          <- sum(enr.times.all <= cutoff.time)
# mon.result.final                 <- monitoring(index = n.final) # calls prior_data_conflict(), takes time
# futility.final                   <- mon.result.final$fut.prob
# efficacy.final                   <- mon.result.final$eff.prob
# inner[i, "fut.mon.final"]        <- (futility.final > sig.fut)
# inner[i, "eff.mon.final"]        <- (efficacy.final > sig.eff)
# inner[i, "eff.mix.prob"]         <- mon.result.final$eff.mix.prob
# pm.cp.result.final               <- pm_cp(index = n.final) # calls prior_data_conflict(), takes time
# inner[i, "post.mean.final.PC"]   <- pm.cp.result.final$pm.mean.x
# inner[i, "post.mean.final.IP"]   <- pm.cp.result.final$pm.mean.y
# inner[i, "cov.final"]            <- pm.cp.result.final$coverage
# inner[i, "mle.final.PC"]         <- pm.cp.result.final$mle.PC
# inner[i, "mle.final.IP"]         <- pm.cp.result.final$mle.IP
# inner[i, "ss.final"]             <- n.final
# inner[i, "final.p"]              <- efficacy.final
# inner[i, "risk.diff.final"]      <- mon.result.final$risk.diff.mle
# inner[i, "box.skpt.final"]       <- mon.result.final$skpt.psi
# inner[i, "box.enth.final"]       <- mon.result.final$enth.psi
# inner[i, "box.ni.final"]         <- mon.result.final$ni.psi
}
Table0     <- data.frame(t(inner))
Table0$idx <- idx
write.csv(Table0, file = paste0("../output/Table0/", idx, "Table0.csv"))
}
##################################
### Risk difference simulations
### Evan Kwiatkowski, Feb 2020
###
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
##################################
for (idx in 1:5){ # check here
if (Sys.getenv("USER") == "kwiatkoe") {
library(pracma)
library(gnorm)
} else {                                    # longleaf
library(pracma, lib.loc = "../rpkgs/")
library(gnorm,  lib.loc = "../rpkgs/")
args <- commandArgs(trailingOnly = TRUE)  # sequence from batch file
idx  <- as.numeric(args[1]);
}
# Model information, including all functions used (The only additional source file to be called is "code_enrollment.R")
load(file = 'args_model.RData') # loads all model information include prior parameters AND SETS SEED
set.seed(idx*623202)  #  05-19-2020
# Simulation information
simulation <- read.csv(file = "args_simulation.csv", header = TRUE, sep = ",")
for(i in 1:ncol(simulation)){
assign(names(simulation)[i], simulation[idx, names(simulation)[i]])
}
# Simulations ---
names <- c("eff.mon.initial","eff.mon.final","fut.mon.initial","fut.mon.final",
"ss.initial","ss.final",
"mle.initial.IP","mle.final.IP","mle.initial.PC","mle.final.PC",
"post.mean.initial.IP","post.mean.final.IP","post.mean.initial.PC","post.mean.final.PC",
"cov.initial","cov.final",
"eff.mix.prob",
"initial.p", "final.p",
"box.skpt.initial", "box.skpt.final",
"box.enth.initial", "box.enth.final",
"box.ni.initial",   "box.ni.final",
"risk.diff.initial", "risk.diff.final")
inner <- array(NA,
dim = c(reps, length(names)),
dimnames = list(seq_len(reps), names))
for (i in 1:reps){
{print(paste0("IDX ", idx, ", Simulation ", i))}
source("04_code_enrollment.R")
#for (j in unique(c(seq(min.ss, max.ss, by = freq.mntr), max.ss))){
for(j in max.ss){
#{print(paste0("Inner loop: ", j))}
mon.result.initial <- monitoring(index = j)
futility           <- mon.result.initial$fut.prob
efficacy           <- mon.result.initial$eff.prob
if (futility > sig.fut | efficacy > sig.eff){
break
}
}
# Initial
n.initial                        <- j
inner[i, "fut.mon.initial"]      <- (futility > sig.fut)
inner[i, "eff.mon.initial"]      <- (efficacy > sig.eff)
# pm.cp.result.initial             <- pm_cp(index = n.initial) # calls prior_data_conflict(), takes time
# inner[i, "post.mean.initial.PC"] <- pm.cp.result.initial$pm.mean.x
# inner[i, "post.mean.initial.IP"] <- pm.cp.result.initial$pm.mean.y
# inner[i, "mle.initial.PC"]       <- pm.cp.result.initial$mle.PC
# inner[i, "mle.initial.IP"]       <- pm.cp.result.initial$mle.IP
# inner[i, "cov.initial"]          <- pm.cp.result.initial$coverage
inner[i, "ss.initial"]           <- n.initial
inner[i, "initial.p"]            <- efficacy
inner[i, "risk.diff.initial"]    <- mon.result.initial$risk.diff.mle
inner[i, "box.skpt.initial"]     <- mon.result.initial$skpt.psi
inner[i, "box.enth.initial"]     <- mon.result.initial$enth.psi
inner[i, "box.ni.initial"]       <- mon.result.initial$ni.psi
# # Final ---
# cutoff.time                      <- outcome.times.all[n.initial]
# n.final                          <- sum(enr.times.all <= cutoff.time)
# mon.result.final                 <- monitoring(index = n.final) # calls prior_data_conflict(), takes time
# futility.final                   <- mon.result.final$fut.prob
# efficacy.final                   <- mon.result.final$eff.prob
# inner[i, "fut.mon.final"]        <- (futility.final > sig.fut)
# inner[i, "eff.mon.final"]        <- (efficacy.final > sig.eff)
# inner[i, "eff.mix.prob"]         <- mon.result.final$eff.mix.prob
# pm.cp.result.final               <- pm_cp(index = n.final) # calls prior_data_conflict(), takes time
# inner[i, "post.mean.final.PC"]   <- pm.cp.result.final$pm.mean.x
# inner[i, "post.mean.final.IP"]   <- pm.cp.result.final$pm.mean.y
# inner[i, "cov.final"]            <- pm.cp.result.final$coverage
# inner[i, "mle.final.PC"]         <- pm.cp.result.final$mle.PC
# inner[i, "mle.final.IP"]         <- pm.cp.result.final$mle.IP
# inner[i, "ss.final"]             <- n.final
# inner[i, "final.p"]              <- efficacy.final
# inner[i, "risk.diff.final"]      <- mon.result.final$risk.diff.mle
# inner[i, "box.skpt.final"]       <- mon.result.final$skpt.psi
# inner[i, "box.enth.final"]       <- mon.result.final$enth.psi
# inner[i, "box.ni.final"]         <- mon.result.final$ni.psi
}
Table0     <- data.frame(t(inner))
Table0$idx <- idx
write.csv(Table0, file = paste0("../output/Table0/", idx, "Table0.csv"))
}
##################################
# Model parameters
# Evan Kwiatkowski, Jun 22, 2020
##################################
read.tcsv = function(file, header=TRUE, sep=",", ...) {
n = max(count.fields(file, sep=sep), na.rm=TRUE)
x = readLines(file)
.splitvar = function(x, sep, n) {
var = unlist(strsplit(x, split=sep))
length(var) = n
return(var)
}
x = do.call(cbind, lapply(x, .splitvar, sep=sep, n=n))
x = apply(x, 1, paste, collapse=sep)
out = read.csv(text=x, sep=sep, header=header, ...)
return(out)
}
file_list <- list.files(paste0("../output/Table0"))
for (i in 1:length(file_list)){
temp <- read.tcsv(paste0("../output/Table0/", file_list[i]), header = TRUE)
temp$idx <- temp[nrow(temp),2]
temp <- temp[1:(nrow(temp)-1),]
if (i==1) {
final <- temp
} else {
final <- rbind(final,temp)
}
}
args_simulation <- read.csv(file = "args_simulation.csv", header = TRUE, sep = ",")
final           <- final[,-1]
combined        <- merge(args_simulation, final, by.x = "X", by.y = "idx")
write.csv(combined, file = "Table0_merged.csv") # will be used to bring back from longleaf
delta.ni.enth <- 0.36
delta.ni.skpt <- 0.06
delta.ni.intr <- (delta.ni.skpt+delta.ni.enth)/2
0.06-.3
##################################
# Model parameters
# Evan Kwiatkowski, Feb 23, 2020
##################################
rm(list = ls())
if (Sys.getenv("USER") == "kwiatkoe") {
library(pracma)
library(gnorm)
setwd("/Users/kwiatkoe/Documents/GitHub/Bayesian-Sequential-Monitoring/00-paper/FIGURES/riskdiff/code")
}
if (.Platform$OS.type == "unix")    {
library(pracma, lib.loc = "../rpkgs/")
library(gnorm,  lib.loc = "../rpkgs/")
}
delta.enth <- 0.12
delta.skpt <- 0
delta.intr <- (delta.skpt+delta.enth)/2
mu         <- 0.39
sig.fut    <- 0.975
sig.eff    <- 0.975
source("03_code_integrate.R")
source("06_code_functions.R") # contains nested source("code_posteriors.R", local = TRUE)
source("priors/03_enth_joint.R")
enth_joint()
source("priors/06_skpt_joint.R")
skpt_joint()
delta.ni.enth <- 0.36
delta.ni.skpt <- 0.06
delta.ni.intr <- (delta.ni.skpt+delta.ni.enth)/2
source("priors/09_ni_joint.R")
ni_joint()
save.image(file = 'args_model.RData')
##################################
### Risk difference simulations
### Evan Kwiatkowski, Feb 2020
###
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
### # If changes made to functions then re-run args_model.R
##################################
for (idx in 1:5){ # check here
if (Sys.getenv("USER") == "kwiatkoe") {
library(pracma)
library(gnorm)
} else {                                    # longleaf
library(pracma, lib.loc = "../rpkgs/")
library(gnorm,  lib.loc = "../rpkgs/")
args <- commandArgs(trailingOnly = TRUE)  # sequence from batch file
idx  <- as.numeric(args[1]);
}
# Model information, including all functions used (The only additional source file to be called is "code_enrollment.R")
load(file = 'args_model.RData') # loads all model information include prior parameters AND SETS SEED
set.seed(idx*623202)  #  05-19-2020
# Simulation information
simulation <- read.csv(file = "args_simulation.csv", header = TRUE, sep = ",")
for(i in 1:ncol(simulation)){
assign(names(simulation)[i], simulation[idx, names(simulation)[i]])
}
# Simulations ---
names <- c("eff.mon.initial","eff.mon.final","fut.mon.initial","fut.mon.final",
"ss.initial","ss.final",
"mle.initial.IP","mle.final.IP","mle.initial.PC","mle.final.PC",
"post.mean.initial.IP","post.mean.final.IP","post.mean.initial.PC","post.mean.final.PC",
"cov.initial","cov.final",
"eff.mix.prob",
"initial.p", "final.p",
"box.skpt.initial", "box.skpt.final",
"box.enth.initial", "box.enth.final",
"box.ni.initial",   "box.ni.final",
"risk.diff.initial", "risk.diff.final")
inner <- array(NA,
dim = c(reps, length(names)),
dimnames = list(seq_len(reps), names))
for (i in 1:reps){
{print(paste0("IDX ", idx, ", Simulation ", i))}
source("04_code_enrollment.R")
#for (j in unique(c(seq(min.ss, max.ss, by = freq.mntr), max.ss))){
for(j in max.ss){
#{print(paste0("Inner loop: ", j))}
mon.result.initial <- monitoring(index = j)
futility           <- mon.result.initial$fut.prob
efficacy           <- mon.result.initial$eff.prob
if (futility > sig.fut | efficacy > sig.eff){
break
}
}
# Initial
n.initial                        <- j
inner[i, "fut.mon.initial"]      <- (futility > sig.fut)
inner[i, "eff.mon.initial"]      <- (efficacy > sig.eff)
# pm.cp.result.initial             <- pm_cp(index = n.initial) # calls prior_data_conflict(), takes time
# inner[i, "post.mean.initial.PC"] <- pm.cp.result.initial$pm.mean.x
# inner[i, "post.mean.initial.IP"] <- pm.cp.result.initial$pm.mean.y
# inner[i, "mle.initial.PC"]       <- pm.cp.result.initial$mle.PC
# inner[i, "mle.initial.IP"]       <- pm.cp.result.initial$mle.IP
# inner[i, "cov.initial"]          <- pm.cp.result.initial$coverage
inner[i, "ss.initial"]           <- n.initial
inner[i, "initial.p"]            <- efficacy
inner[i, "risk.diff.initial"]    <- mon.result.initial$risk.diff.mle
inner[i, "box.skpt.initial"]     <- mon.result.initial$skpt.psi
inner[i, "box.enth.initial"]     <- mon.result.initial$enth.psi
inner[i, "box.ni.initial"]       <- mon.result.initial$ni.psi
# # Final ---
# cutoff.time                      <- outcome.times.all[n.initial]
# n.final                          <- sum(enr.times.all <= cutoff.time)
# mon.result.final                 <- monitoring(index = n.final) # calls prior_data_conflict(), takes time
# futility.final                   <- mon.result.final$fut.prob
# efficacy.final                   <- mon.result.final$eff.prob
# inner[i, "fut.mon.final"]        <- (futility.final > sig.fut)
# inner[i, "eff.mon.final"]        <- (efficacy.final > sig.eff)
# inner[i, "eff.mix.prob"]         <- mon.result.final$eff.mix.prob
# pm.cp.result.final               <- pm_cp(index = n.final) # calls prior_data_conflict(), takes time
# inner[i, "post.mean.final.PC"]   <- pm.cp.result.final$pm.mean.x
# inner[i, "post.mean.final.IP"]   <- pm.cp.result.final$pm.mean.y
# inner[i, "cov.final"]            <- pm.cp.result.final$coverage
# inner[i, "mle.final.PC"]         <- pm.cp.result.final$mle.PC
# inner[i, "mle.final.IP"]         <- pm.cp.result.final$mle.IP
# inner[i, "ss.final"]             <- n.final
# inner[i, "final.p"]              <- efficacy.final
# inner[i, "risk.diff.final"]      <- mon.result.final$risk.diff.mle
# inner[i, "box.skpt.final"]       <- mon.result.final$skpt.psi
# inner[i, "box.enth.final"]       <- mon.result.final$enth.psi
# inner[i, "box.ni.final"]         <- mon.result.final$ni.psi
}
Table0     <- data.frame(t(inner))
Table0$idx <- idx
write.csv(Table0, file = paste0("../output/Table0/", idx, "Table0.csv"))
}
##################################
# Model parameters
# Evan Kwiatkowski, Jun 22, 2020
##################################
read.tcsv = function(file, header=TRUE, sep=",", ...) {
n = max(count.fields(file, sep=sep), na.rm=TRUE)
x = readLines(file)
.splitvar = function(x, sep, n) {
var = unlist(strsplit(x, split=sep))
length(var) = n
return(var)
}
x = do.call(cbind, lapply(x, .splitvar, sep=sep, n=n))
x = apply(x, 1, paste, collapse=sep)
out = read.csv(text=x, sep=sep, header=header, ...)
return(out)
}
file_list <- list.files(paste0("../output/Table0"))
for (i in 1:length(file_list)){
temp <- read.tcsv(paste0("../output/Table0/", file_list[i]), header = TRUE)
temp$idx <- temp[nrow(temp),2]
temp <- temp[1:(nrow(temp)-1),]
if (i==1) {
final <- temp
} else {
final <- rbind(final,temp)
}
}
args_simulation <- read.csv(file = "args_simulation.csv", header = TRUE, sep = ",")
final           <- final[,-1]
combined        <- merge(args_simulation, final, by.x = "X", by.y = "idx")
write.csv(combined, file = "Table0_merged.csv") # will be used to bring back from longleaf
