#outer_trial_result_ss<-vector(length=length(pi_range)) # expected sample size
#outer_p_hat<-vector(length=length(pi_range))
for (j in 1:length(pi_range)){
## OUTER LOOP OVER TRIALS
reps<-1000
trial_result<-vector(length=reps)
trial_result_binary<-vector(length=reps)
trial_result_ss<-vector(length=reps)
#freq_trial_result<-vector(length=reps)
#inner_p_hat<-vector(length=reps)
for (i in 1:reps){
## INNER LOOP OVER SAMPLE
futility<-0 # initialize
efficacy<-0 # initialize
n<-1 # initializing sample size
y1_before<-0 # initializing number of successes
while (n<=freq_ss){
# generate trial result
y<-rbinom(1,size=1,prob=pi_range[j])
# new number of successes
y1<-sum(y1_before)+y
# new number of failures
y0<-n-y1
# futility (even optimst would give up)
futility<-pbeta(theta_L,alpha_H+y1,beta_H+y0,lower.tail=TRUE)
# efficacy (even pessimist would accept)
efficacy<-pbeta(theta_H,alpha_L+y1,beta_L+y0,lower.tail=FALSE)
## for next loop
y1_before<-y1
n<-n+1
if (n%%check_vector[k]==0 & (futility>.5 | efficacy>.5)){
break
}
}
## Posterior model probabilities, slide 133/1005 of 779 notes
# posterior probability of data given models
post_L_D<-(beta(alpha_L,beta_L))^(-1)*beta(alpha_L+y1,beta_L+y0)
post_H_D<-(beta(alpha_H,beta_H))^(-1)*beta(alpha_H+y1,beta_H+y0)
# posterior probability of models given data
post_L<-post_L_D*prior_L/(post_L_D*prior_L+post_H_D*prior_H)
post_H<-post_H_D*prior_H/(post_L_D*prior_L+post_H_D*prior_H)
## compute probability of event A given the models, slide 7/1005 of 779 notes
post_L_eventA<-pbeta(theta_L,alpha_L+y1,beta_L+y0,lower.tail=FALSE)
post_H_eventA<-pbeta(theta_L,alpha_H+y1,beta_H+y0,lower.tail=FALSE)
# compute probability of event A
trial_result[i]<-sum(post_L*post_L_eventA,post_H*post_H_eventA)
trial_result_binary[i]=(trial_result[i]>=0.95) # rejecting null hypothesis
trial_result_ss[i]<-n-1
#inner_p_hat[i]<-(y1/n-pi_range[j])
#freq_trial_result[i]<-((sqrt(n)*(pi_range[j]-p_hat-delta_0)/sqrt(p_hat*(1-p_hat))<qnorm(alpha)) &
#    (sqrt(n)*(pi_range[j]-p_hat+delta_0)/sqrt(p_hat*(1-p_hat))>qnorm(1-alpha)))
}
outer_trial_result_binary[k,j]<-mean(trial_result_binary) # sent to final results matrix
outer_trial_result[k,j]<-mean(trial_result)
#outer_freq_trial_result[j]<-mean(freq_trial_result)
outer_trial_result_ss[k,j]<-mean(trial_result_ss)
#outer_p_hat[j]<-mean(inner_p_hat)
}
}
outer_trial_result_binary # probability of rejecting null hypothesis (alpha at theta_L, 1-beta at theta_H)
outer_trial_result
outer_trial_result_ss
plot(pi_range,outer_trial_result_binary[1,],type='l')
lines(pi_range,outer_trial_result_binary[2,],type='l')
lines(pi_range,outer_trial_result_binary[3,],type='l')
lines(pi_range,outer_trial_result_binary[4,],type='l')
install.packages("plotly")
rm(list = ls())
library(plotly)
df <- read.csv("https://raw.githubusercontent.com/plotly/datasets/master/violin_data.csv")
pointposMale <- c(-0.9,-1.1,-0.6,-0.3)
pointposFemale <- c(0.45,0.55,1,0.4)
showLegend <- c(T,F,F,F)
p <- plot_ly(type = 'violin')
i = 0
for (i in 1:length(unique(df$day))) {
p <- add_trace(
p,
x = df$day[df$sex == 'Male' & df$day == unique(df$day)[i]],
y = df$total_bill[df$sex == 'Male' & df$day == unique(df$day)[i]],
hoveron = "points+kde",
legendgroup = 'M',
scalegroup = 'M',
name = 'M',
side = 'negative',
box = list(
visible = T
),
points = 'all',
pointpos = pointposMale[i],
jitter = 0,
scalemode = 'count',
meanline = list(
visible = T
),
line = list(
color = "#8dd3c7"
),
marker = list(
line = list(
width = 2,
color = "#8dd3c7"
),
symbol = 'line-ns'
),
showlegend = showLegend[i]
) %>%
add_trace(
x = df$day[df$sex == 'Female' & df$day == unique(df$day)[i]],
y = df$total_bill[df$sex == 'Female' & df$day == unique(df$day)[i]],
hoveron = "points+kde",
legendgroup = 'F',
scalegroup = 'F',
name = 'F',
side = 'positive',
box = list(
visible = T
),
points = 'all',
pointpos = pointposFemale[i],
jitter = 0,
scalemode = 'count',
meanline = list(
visible = T
),
line = list(
color = "#bebada"
),
marker = list(
line = list(
width = 2,
color = "#bebada"
),
symbol = 'line-ns'
),
showlegend = showLegend[i]
)
}
p <- layout(
p,
title = "Total bill distribution<br><i>scaled by number of bills per gender",
yaxis = list(
zeroline = F
),
violingap = 0,
violingroupgap = 0,
violinmode = 'overlay',
legend = list(
tracegroupgap = 0
)
)
# Create a shareable link to your chart
# Set up API credentials: https://plot.ly/r/getting-started
chart_link <- api_create(p, filename = "violin-advanced")
chart_link
rm(list = ls())
library(plotly)
df <- read.csv("https://raw.githubusercontent.com/plotly/datasets/master/violin_data.csv")
pointposMale <- c(-0.9,-1.1,-0.6,-0.3)
pointposFemale <- c(0.45,0.55,1,0.4)
showLegend <- c(T,F,F,F)
p <- plot_ly(type = 'violin')
i = 0
for (i in 1:length(unique(df$day))) {
p <- add_trace(
p,
x = df$day[df$sex == 'Male' & df$day == unique(df$day)[i]],
y = df$total_bill[df$sex == 'Male' & df$day == unique(df$day)[i]],
hoveron = "points+kde",
legendgroup = 'M',
scalegroup = 'M',
name = 'M',
side = 'negative',
box = list(
visible = T
),
points = 'all',
pointpos = pointposMale[i],
jitter = 0,
scalemode = 'count',
meanline = list(
visible = T
),
line = list(
color = "#8dd3c7"
),
marker = list(
line = list(
width = 2,
color = "#8dd3c7"
),
symbol = 'line-ns'
),
showlegend = showLegend[i]
) %>%
add_trace(
x = df$day[df$sex == 'Female' & df$day == unique(df$day)[i]],
y = df$total_bill[df$sex == 'Female' & df$day == unique(df$day)[i]],
hoveron = "points+kde",
legendgroup = 'F',
scalegroup = 'F',
name = 'F',
side = 'positive',
box = list(
visible = T
),
points = 'all',
pointpos = pointposFemale[i],
jitter = 0,
scalemode = 'count',
meanline = list(
visible = T
),
line = list(
color = "#bebada"
),
marker = list(
line = list(
width = 2,
color = "#bebada"
),
symbol = 'line-ns'
),
showlegend = showLegend[i]
)
}
p <- layout(
p,
title = "Total bill distribution<br><i>scaled by number of bills per gender",
yaxis = list(
zeroline = F
),
violingap = 0,
violingroupgap = 0,
violinmode = 'overlay',
legend = list(
tracegroupgap = 0
)
)
chart_link
rm(list = ls())
library(plotly)
df <- read.csv("https://raw.githubusercontent.com/plotly/datasets/master/violin_data.csv")
pointposMale <- c(-0.9,-1.1,-0.6,-0.3)
pointposFemale <- c(0.45,0.55,1,0.4)
showLegend <- c(T,F,F,F)
p <- plot_ly(type = 'violin')
i = 0
for (i in 1:length(unique(df$day))) {
p <- add_trace(
p,
x = df$day[df$sex == 'Male' & df$day == unique(df$day)[i]],
y = df$total_bill[df$sex == 'Male' & df$day == unique(df$day)[i]],
hoveron = "points+kde",
legendgroup = 'M',
scalegroup = 'M',
name = 'M',
side = 'negative',
box = list(
visible = T
),
points = 'all',
pointpos = pointposMale[i],
jitter = 0,
scalemode = 'count',
meanline = list(
visible = T
),
line = list(
color = "#8dd3c7"
),
marker = list(
line = list(
width = 2,
color = "#8dd3c7"
),
symbol = 'line-ns'
),
showlegend = showLegend[i]
) %>%
add_trace(
x = df$day[df$sex == 'Female' & df$day == unique(df$day)[i]],
y = df$total_bill[df$sex == 'Female' & df$day == unique(df$day)[i]],
hoveron = "points+kde",
legendgroup = 'F',
scalegroup = 'F',
name = 'F',
side = 'positive',
box = list(
visible = T
),
points = 'all',
pointpos = pointposFemale[i],
jitter = 0,
scalemode = 'count',
meanline = list(
visible = T
),
line = list(
color = "#bebada"
),
marker = list(
line = list(
width = 2,
color = "#bebada"
),
symbol = 'line-ns'
),
showlegend = showLegend[i]
)
}
p <- layout(
p,
title = "Total bill distribution<br><i>scaled by number of bills per gender",
yaxis = list(
zeroline = F
),
violingap = 0,
violingroupgap = 0,
violinmode = 'overlay',
legend = list(
tracegroupgap = 0
)
)
p
rm(list = ls())
df <- read.csv("https://raw.githubusercontent.com/plotly/datasets/master/violin_data.csv")
p <- df %>%
plot_ly(type = 'violin') %>%
add_trace(
x = ~day[df$smoker == 'Yes'],
y = ~total_bill[df$smoker == 'Yes'],
legendgroup = 'Yes',
scalegroup = 'Yes',
name = 'Yes',
side = 'negative',
box = list(
visible = T
),
meanline = list(
visible = T
),
line = list(
color = 'blue'
)
) %>%
add_trace(
x = ~day[df$smoker == 'No'],
y = ~total_bill[df$smoker == 'No'],
legendgroup = 'No',
scalegroup = 'No',
name = 'No',
side = 'positive',
box = list(
visible = T
),
meanline = list(
visible = T
),
line = list(
color = 'green'
)
) %>%
layout(
xaxis = list(
title = ""
),
yaxis = list(
title = "",
zeroline = F
),
violingap = 0,
violingroupgap = 0,
violinmode = 'overlay'
)
p
GeomSplitViolin <- ggproto("GeomSplitViolin", GeomViolin,
draw_group = function(self, data, ..., draw_quantiles = NULL) {
data <- transform(data, xminv = x - violinwidth * (x - xmin), xmaxv = x + violinwidth * (xmax - x))
grp <- data[1, "group"]
newdata <- plyr::arrange(transform(data, x = if (grp %% 2 == 1) xminv else xmaxv), if (grp %% 2 == 1) y else -y)
newdata <- rbind(newdata[1, ], newdata, newdata[nrow(newdata), ], newdata[1, ])
newdata[c(1, nrow(newdata) - 1, nrow(newdata)), "x"] <- round(newdata[1, "x"])
if (length(draw_quantiles) > 0 & !scales::zero_range(range(data$y))) {
stopifnot(all(draw_quantiles >= 0), all(draw_quantiles <=
1))
quantiles <- ggplot2:::create_quantile_segment_frame(data, draw_quantiles)
aesthetics <- data[rep(1, nrow(quantiles)), setdiff(names(data), c("x", "y")), drop = FALSE]
aesthetics$alpha <- rep(1, nrow(quantiles))
both <- cbind(quantiles, aesthetics)
quantile_grob <- GeomPath$draw_panel(both, ...)
ggplot2:::ggname("geom_split_violin", grid::grobTree(GeomPolygon$draw_panel(newdata, ...), quantile_grob))
}
else {
ggplot2:::ggname("geom_split_violin", GeomPolygon$draw_panel(newdata, ...))
}
})
geom_split_violin <- function(mapping = NULL, data = NULL, stat = "ydensity", position = "identity", ...,
draw_quantiles = NULL, trim = TRUE, scale = "area", na.rm = FALSE,
show.legend = NA, inherit.aes = TRUE) {
layer(data = data, mapping = mapping, stat = stat, geom = GeomSplitViolin,
position = position, show.legend = show.legend, inherit.aes = inherit.aes,
params = list(trim = trim, scale = scale, draw_quantiles = draw_quantiles, na.rm = na.rm, ...))
rm(list = ls())
GeomSplitViolin <- ggproto("GeomSplitViolin", GeomViolin,
draw_group = function(self, data, ..., draw_quantiles = NULL) {
data <- transform(data, xminv = x - violinwidth * (x - xmin), xmaxv = x + violinwidth * (xmax - x))
grp <- data[1, "group"]
newdata <- plyr::arrange(transform(data, x = if (grp %% 2 == 1) xminv else xmaxv), if (grp %% 2 == 1) y else -y)
newdata <- rbind(newdata[1, ], newdata, newdata[nrow(newdata), ], newdata[1, ])
newdata[c(1, nrow(newdata) - 1, nrow(newdata)), "x"] <- round(newdata[1, "x"])
if (length(draw_quantiles) > 0 & !scales::zero_range(range(data$y))) {
stopifnot(all(draw_quantiles >= 0), all(draw_quantiles <=
1))
quantiles <- ggplot2:::create_quantile_segment_frame(data, draw_quantiles)
aesthetics <- data[rep(1, nrow(quantiles)), setdiff(names(data), c("x", "y")), drop = FALSE]
aesthetics$alpha <- rep(1, nrow(quantiles))
both <- cbind(quantiles, aesthetics)
quantile_grob <- GeomPath$draw_panel(both, ...)
ggplot2:::ggname("geom_split_violin", grid::grobTree(GeomPolygon$draw_panel(newdata, ...), quantile_grob))
}
else {
ggplot2:::ggname("geom_split_violin", GeomPolygon$draw_panel(newdata, ...))
}
})
geom_split_violin <- function(mapping = NULL, data = NULL, stat = "ydensity", position = "identity", ...,
draw_quantiles = NULL, trim = TRUE, scale = "area", na.rm = FALSE,
show.legend = NA, inherit.aes = TRUE) {
layer(data = data, mapping = mapping, stat = stat, geom = GeomSplitViolin,
position = position, show.legend = show.legend, inherit.aes = inherit.aes,
params = list(trim = trim, scale = scale, draw_quantiles = draw_quantiles, na.rm = na.rm, ...))
}
rm(list = ls())
GeomSplitViolin <- ggproto("GeomSplitViolin", GeomViolin,
draw_group = function(self, data, ..., draw_quantiles = NULL) {
data <- transform(data, xminv = x - violinwidth * (x - xmin), xmaxv = x + violinwidth * (xmax - x))
grp <- data[1, "group"]
newdata <- plyr::arrange(transform(data, x = if (grp %% 2 == 1) xminv else xmaxv), if (grp %% 2 == 1) y else -y)
newdata <- rbind(newdata[1, ], newdata, newdata[nrow(newdata), ], newdata[1, ])
newdata[c(1, nrow(newdata) - 1, nrow(newdata)), "x"] <- round(newdata[1, "x"])
if (length(draw_quantiles) > 0 & !scales::zero_range(range(data$y))) {
stopifnot(all(draw_quantiles >= 0), all(draw_quantiles <=
1))
quantiles <- ggplot2:::create_quantile_segment_frame(data, draw_quantiles)
aesthetics <- data[rep(1, nrow(quantiles)), setdiff(names(data), c("x", "y")), drop = FALSE]
aesthetics$alpha <- rep(1, nrow(quantiles))
both <- cbind(quantiles, aesthetics)
quantile_grob <- GeomPath$draw_panel(both, ...)
ggplot2:::ggname("geom_split_violin", grid::grobTree(GeomPolygon$draw_panel(newdata, ...), quantile_grob))
}
else {
ggplot2:::ggname("geom_split_violin", GeomPolygon$draw_panel(newdata, ...))
}
})
geom_split_violin <- function(mapping = NULL, data = NULL, stat = "ydensity", position = "identity", ...,
draw_quantiles = NULL, trim = TRUE, scale = "area", na.rm = FALSE,
show.legend = NA, inherit.aes = TRUE) {
layer(data = data, mapping = mapping, stat = stat, geom = GeomSplitViolin,
position = position, show.legend = show.legend, inherit.aes = inherit.aes,
params = list(trim = trim, scale = scale, draw_quantiles = draw_quantiles, na.rm = na.rm, ...))
}
df <- read.csv("https://raw.githubusercontent.com/plotly/datasets/master/violin_data.csv")
p <- df %>%
plot_ly(type = 'violin') %>%
add_trace(
x = ~day[df$smoker == 'Yes'],
y = ~total_bill[df$smoker == 'Yes'],
legendgroup = 'Yes',
scalegroup = 'Yes',
name = 'Yes',
side = 'negative',
box = list(
visible = T
),
meanline = list(
visible = T
),
line = list(
color = 'blue'
)
) %>%
add_trace(
x = ~day[df$smoker == 'No'],
y = ~total_bill[df$smoker == 'No'],
legendgroup = 'No',
scalegroup = 'No',
name = 'No',
side = 'positive',
box = list(
visible = T
),
meanline = list(
visible = T
),
line = list(
color = 'green'
)
) %>%
layout(
xaxis = list(
title = ""
),
yaxis = list(
title = "",
zeroline = F
),
violingap = 0,
violingroupgap = 0,
violinmode = 'overlay'
)
p
dd
