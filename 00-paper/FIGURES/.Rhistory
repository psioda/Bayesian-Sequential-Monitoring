p<-c(0,0.205,0.70,0.045,0.05)
# do a grid search for this piece
(sum(p)==1) # check p
x<-seq(0,1,length=10000)
#x<-x[-c(1,length(x))]
fx<-0
for (i in 1:length(x)){
if (q[1]<x[i] & x[i]<=q[2]) fx[i]=p[2]/(q[2]-q[1])
if (q[2]<x[i] & x[i]<=q[3]) fx[i]=p[3]/(q[3]-q[2])
if (q[3]<x[i] & x[i]<=q[4]) fx[i]=p[4]/(q[4]-q[3])
if (q[4]<x[i] & x[i]<=q[5]) fx[i]=2*p[5]*(1-x[i])/(q[5]-q[4])^2 # make last segment a triangle
}
mean(x*fx)
q<-c(0,0.15,0.25,0.40,1.00)
p<-c(0,0.205,0.70,0.045,0.05)
# do a grid search for this piece
(sum(p)==1) # check p
x<-seq(0,1,length=10000)
#x<-x[-c(1,length(x))]
y<-0
for (i in 1:length(x)){
if (q[1]<x[i] & x[i]<=q[2]) y[i]=p[2]/(q[2]-q[1])
if (q[2]<x[i] & x[i]<=q[3]) y[i]=p[3]/(q[3]-q[2])
if (q[3]<x[i] & x[i]<=q[4]) y[i]=p[4]/(q[4]-q[3])
if (q[4]<x[i] & x[i]<=q[5]) y[i]=2*p[5]*(1-x[i])/(q[5]-q[4])^2 # make last segment a triangle
}
mean(x*y)
m <- betamix(y ~ 1 | 1, data = d, k = 2)
mu <- plogis(coef(m)[,1]) # plogis distribution of logistic function # [,1] is intercept
phi <- exp(coef(m)[,2])   # [,2] is phi
a <- mu * phi
b <- (1 - mu) * phi
w <- prior(m$flexmix) # probability of clusters for mixture
d <- data.frame(y=y)
m <- betamix(y ~ 1 | 1, data = d, k = 2)
mu <- plogis(coef(m)[,1]) # plogis distribution of logistic function # [,1] is intercept
phi <- exp(coef(m)[,2])   # [,2] is phi
a <- mu * phi
b <- (1 - mu) * phi
w <- prior(m$flexmix) # probability of clusters for mixture
rm(list = ls())
require(flexmix)
require(betareg)
#################################################################################################
## Generate fake data ###########################################################################
#################################################################################################
# # parameters of distribution #1
# alpha1 <- 10
# beta1 <- 30
# # parameters of distribution #2
# alpha2 <- 30
# beta2 <- 10
# # Generate bimodal data
# set.seed(0)
# d <- data.frame(y = c(rbeta(100, alpha1, beta1), rbeta(50, alpha2, beta2)))
# n <- length(d$y)
# # histogram
# par(mfrow=c(1,1))
# hist(d$y, 50)
q<-c(0,0.15,0.25,0.40,1.00)
p<-c(0,0.205,0.70,0.045,0.05)
# do a grid search for this piece
(sum(p)==1) # check p
x<-seq(0,1,length=10002)
x<-x[-c(1,length(x))]
y<-0
for (i in 1:length(x)){
if (q[1]<x[i] & x[i]<=q[2]) y[i]=p[2]/(q[2]-q[1])
if (q[2]<x[i] & x[i]<=q[3]) y[i]=p[3]/(q[3]-q[2])
if (q[3]<x[i] & x[i]<=q[4]) y[i]=p[4]/(q[4]-q[3])
if (q[4]<x[i] & x[i]<=q[5]) y[i]=2*p[5]*(1-x[i])/(q[5]-q[4])^2 # make last segment a triangle
}
mean(x*y)
d <- data.frame(y=y)
#################################################################################################
## Gitting mixtures of beta distributions ######################################################
#################################################################################################
m <- betamix(y ~ 1 | 1, data = d, k = 2)
mu <- plogis(coef(m)[,1]) # plogis distribution of logistic function # [,1] is intercept
phi <- exp(coef(m)[,2])   # [,2] is phi
a <- mu * phi
b <- (1 - mu) * phi
w <- prior(m$flexmix) # probability of clusters for mixture
x
q<-c(0,0.15,0.25,0.40,1.00)
p<-c(0,0.205,0.70,0.045,0.05)
# do a grid search for this piece
(sum(p)==1) # check p
x<-seq(0,1,length=1002)
x<-x[-c(1,length(x))]
y<-0
for (i in 1:length(x)){
if (q[1]<x[i] & x[i]<=q[2]) y[i]=p[2]/(q[2]-q[1])
if (q[2]<x[i] & x[i]<=q[3]) y[i]=p[3]/(q[3]-q[2])
if (q[3]<x[i] & x[i]<=q[4]) y[i]=p[4]/(q[4]-q[3])
if (q[4]<x[i] & x[i]<=q[5]) y[i]=2*p[5]*(1-x[i])/(q[5]-q[4])^2 # make last segment a triangle
}
mean(x*y)
d <- data.frame(y=y)
m <- betamix(y ~ 1 | 1, data = d, k = 2)
mu <- plogis(coef(m)[,1]) # plogis distribution of logistic function # [,1] is intercept
phi <- exp(coef(m)[,2])   # [,2] is phi
a <- mu * phi
b <- (1 - mu) * phi
w <- prior(m$flexmix) # probability of clusters for mixture
?bpeta
?pbeta
# parameters of distribution #1
alpha1 <- 10
beta1 <- 30
# parameters of distribution #2
alpha2 <- 30
beta2 <- 10
# Generate bimodal data
set.seed(0)
d <- data.frame(y = c(rbeta(100, alpha1, beta1), rbeta(50, alpha2, beta2)))
n <- length(d$y)
# histogram
par(mfrow=c(1,1))
hist(d$y, 50)
y
(sum(p)==1) # check p
q<-c(0,0.15,0.25,0.40,1.00)
p<-c(0,0.205,0.70,0.045,0.05)
# do a grid search for this piece
(sum(p)==1) # check p
x<-seq(0,1,length=10000)
x<-x[-c(1,length(x))]
y<-0
for (i in 1:length(x)){
if (q[1]<x[i] & x[i]<=q[2]) y[i]=p[2]/(q[2]-q[1])
if (q[2]<x[i] & x[i]<=q[3]) y[i]=p[3]/(q[3]-q[2])
if (q[3]<x[i] & x[i]<=q[4]) y[i]=p[4]/(q[4]-q[3])
if (q[4]<x[i] & x[i]<=q[5]) y[i]=2*p[5]*(1-x[i])/(q[5]-q[4])^2 # make last segment a triangle
}
mean(x*y)
d <- data.frame(y=y)
?betamix
rm(list = ls())
require(flexmix)
require(betareg)
#################################################################################################
## Generate fake data ###########################################################################
#################################################################################################
# # parameters of distribution #1
# alpha1 <- 10
# beta1 <- 30
# # parameters of distribution #2
# alpha2 <- 30
# beta2 <- 10
# # Generate bimodal data
# set.seed(0)
# d <- data.frame(y = c(rbeta(100, alpha1, beta1), rbeta(50, alpha2, beta2)))
# n <- length(d$y)
# # histogram
# par(mfrow=c(1,1))
# hist(d$y, 50)
q<-c(0,0.15,0.25,0.40,1.00)
p<-c(0,0.205,0.70,0.045,0.05)
# do a grid search for this piece
(sum(p)==1) # check p
x<-seq(0,1,length=10000)
x<-x[-c(1,length(x))]
fx<-0
for (i in 1:length(x)){
if (q[1]<x[i] & x[i]<=q[2]) fx[i]=p[2]/(q[2]-q[1])
if (q[2]<x[i] & x[i]<=q[3]) fx[i]=p[3]/(q[3]-q[2])
if (q[3]<x[i] & x[i]<=q[4]) fx[i]=p[4]/(q[4]-q[3])
if (q[4]<x[i] & x[i]<=q[5]) fx[i]=2*p[5]*(1-x[i])/(q[5]-q[4])^2 # make last segment a triangle
}
mean(x*fx)
fx
x
# make data to match the distribution function
p*10000
fx
head(fx)
1.3666667*0.15
tail(fx)
c(seq(0,0.15,length=2050),
seq(0.15,0.25,length=7000),
seq(0.25,0.4,length=450))
summary(c(seq(0,0.15,length=2050),
seq(0.15,0.25,length=7000),
seq(0.25,0.4,length=450)))
?seq
fx
tail(fx)
plot(x,x^2)
x<-seq(0,1,length=100)
plot(x,x^2)
hist(x^2)
hist(x)
plot(x,(1-x^2))
hist(x)
plot(x,2*)
plot(x,2*x)
hist(x)
hist(2*x)
plot(x,2*x)
plot(x,(1-2*x))
plot(x,(1-x))
hist(1-x)
plot(x,(1-x))
hist(1-x)
plot(x,2*x)
x<-seq(0,1,length=100)
plot(x,2*x)
plot(x,x^2)
hist(x^2)
x<-seq(0,1,length=1000)
plot(x,2*x)
plot(x,x^2)
hist(x^2)
plot(x,x^2)
plot(x,2*x)
plot(x,x^2)
plot(x,2*x)
hist(x^.5)
x<-seq(0,1,length=10000)
plot(x,2*x)
plot(x,x^2)
hist(x^.5)
hist(1-x^.5)
plot(x,x^.5)
hist(x,x^.5)
hist(xx^.5)
hist(x^.5)
hist(x^.5,bins=1000)
hist(x^.5,breaks=1000)
?hist
hist(x^.5,breaks=seq(0,1,length=10))
hist(x^.5,breaks=seq(0,1,length=100))
x<-seq(0.4,1,length=10000)
hist(x^.5,breaks=seq(0,1,length=100))
x
10^6
evan<-function(x){
1 + 0.00268328*sqrt(138889 - 1000000*x)
}
evan(1)
evan(0)
evan(0.4)
x <- seq(0,1,by=0.1)
# pdf
plot(x,2*x)
# cdf
plot(x,x^2)
# inverse cdf
plot(x,sqrt(x))
# random #s
runif(10,0,1)
hist(sqrt(runif(100,0,1)))
# random #s
hist(sqrt(runif(1000,0,1)))
# random #s
hist(sqrt(runif(10000,0,1)))
# random #s
hist(sqrt(runif(100000,0,1)))
?hist
# random #s
hist(sqrt(runif(100000,0,1)),freq=T)
# random #s
hist(sqrt(runif(100000,0,1)),freq=T)
# random #s
hist(sqrt(runif(100000,0,1)),freq=T)
# random #s
hist(sqrt(runif(100000,0,1)),freq=T)
# random #s
hist(sqrt(runif(100000,0,1)),freq=F)
x<-seq(0.4,1,by=0.1)
# pdf
plot(x, (1-x)/0.6^2*2)
# pdf
plot(x, (1-x)/0.6^2*2,type='l')
# cdf
plot(x,5.55556*x - 2.77778*x^2)
# cdf
plot(x,5.55556*x - 2.77778*x^2,type='l')
# inverse cdf
plot(x,1 + 0.00268328*sqrt(138889 - 50000*x))
# inverse cdf
plot(x,1 + 0.00268328*sqrt(138889 - 50000*x),type='l')
# inverse cdf
invcdf<-function(x){
1 + 0.00268328*sqrt(138889 - 50000*x)
}
plot(x,invcdf(x),type='l')
# random draws
U<-runif(100000,0,1)
hist(invcdf(U),freq=F)
# random draws
U<-runif(100000,0.4,1)
hist(invcdf(U),freq=F)
U
# SO OBVIOUS!!@$#
x <- seq(0,1,by=0.1)
x <- seq(0,1,by=0.1)
# pdf
plot(x,2*x)
# pdf
plot(x,2*x,type='l')
# cdf
plot(x,x^2,type='l')
sqrt(x)
x <- seq(0,1,by=0.1)
# pdf
plot(x,2*x,type='l')
# cdf
plot(x,x^2,type='l')
# inverse cdf
invcdf<-function(x){
sqrt(x)
}
plot(x,invcdf(x))
plot(x,invcdf(x),type='l')
# random draws
hist(invcdf(runif(100000,0,1)),freq=F)
x<-seq(0.4,1,by=0.1)
# pdf
plot(x, (1-x)/0.6^2*2,type='l')
x <- seq(0,1,by=0.1)
# pdf
plot(x,2*x,type='l')
# cdf
plot(x,x^2,type='l')
# inverse cdf
invcdf<-function(x){
sqrt(x)
}
plot(x,invcdf(x),type='l')
# random draws
hist(invcdf(runif(100000,0,1)),freq=F)
plot(x,invcdf(x),type='l')
x<-seq(0.4,1,by=0.1)
# pdf
plot(x, (1-x)/0.6^2*2,type='l')
# cdf
plot(x,5.55556*x - 2.77778*x^2,type='l')
# inverse cdf
invcdf<-function(x){
1 + 0.00268328*sqrt(138889 - 50000*x)
}
plot(x,invcdf(x),type='l')
plot(seq(0,1,by=0.1),invcdf(x),type='l')
plot(seq(0,1,by=0.1),invcdf(seq(0,1,by=0.1)),type='l')
# random draws
U<-runif(100000,0.4,1)
hist(invcdf(U),freq=F)
# pdf
plot(x, (1-x)/0.6^2*2,type='l')
hist(invcdf(U),freq=F)
# random draws
U<-runif(100000,0.4,1)
# inverse cdf
invcdf<-function(x){
1 + 0.00268328*sqrt(138889 - 50000*x)
}
plot(seq(0,1,by=0.1),invcdf(seq(0,1,by=0.1)),type='l')
# random draws
U<-runif(100000,0,1)
hist(invcdf(U),freq=F)
x<-seq(0.4,1,by=0.1)
# pdf
plot(x, (1-x)/0.6^2*2,type='l')
# cdf
plot(x,5.55556*x - 2.77778*x^2,type='l')
x <- seq(0,1,by=0.1)
# pdf
plot(x,2*x,type='l')
# cdf
plot(x,x^2,type='l')
# inverse cdf
invcdf<-function(x){
sqrt(x)
}
plot(x,invcdf(x),type='l')
# random draws
hist(invcdf(runif(100000,0,1)),freq=F)
x<-seq(0.4,1,by=0.1)
# pdf
plot(x, (1-x)/0.6^2*2,type='l')
# cdf
plot(x,5.55556*x - 2.77778*x^2,type='l')
plot(x,cdf(x),type='l')
# cdf
cdf<-function(x){
-1.77778 + 5.55556*x - 2.77778*x^2
}
plot(x,cdf(x),type='l')
# inverse cdf
invcdf<-function(x){
-1.77778 + 5.55556*x - 2.77778*x^2
}
plot(x,cdf(x),type='l')
# inverse cdf
invcdf<-function(x){
1 + 0.6 sqrt(1 - x)
}
1 + 0.6*sqrt(1 - x)
# inverse cdf
invcdf<-function(x){
1 + 0.6*sqrt(1 - x)
}
plot(seq(0,1,by=0.1),invcdf(seq(0,1,by=0.1)),type='l')
# random draws
U<-runif(100000,0,1)
hist(invcdf(U),freq=F)
# random draws
U<-runif(100000,0.4,1)
hist(invcdf(U),freq=F)
# pdf
plot(x,2*x,type='l')
# cdf
plot(x,x^2,type='l')
# inverse cdf
invcdf<-function(x){
sqrt(x)
}
plot(x,invcdf(x),type='l')
# random draws
hist(invcdf(runif(100000,0,1)),freq=F)
x<-seq(0.4,1,by=0.1)
# pdf
plot(x, (1-x)/0.6^2*2,type='l')
# cdf
cdf<-function(x){
-1.77778 + 5.55556*x - 2.77778*x^2
}
plot(x,cdf(x),type='l')
# inverse cdf
invcdf<-function(x){
1 + 0.6*sqrt(1 - x)
}
plot(seq(0,1,by=0.1),invcdf(seq(0,1,by=0.1)),type='l')
plot(x,invcdf(x),type='l')
1 - 0.6*sqrt(1 - x)
# inverse cdf
invcdf<-function(x){
1 - 0.6*sqrt(1 - x)
}
plot(x,invcdf(x),type='l')
# random draws
U<-runif(100000,0.4,1)
hist(invcdf(U),freq=F)
# random draws
U<-runif(100000,0,1)
hist(invcdf(U),freq=F)
invcdf<-function(x){
1 - 0.6*sqrt(1 - x)
}
invcdf(seq(0,1,length=500))
summary(c(seq(0,0.15,length=2050),
seq(0.15,0.25,length=7000),
seq(0.25,0.40,length=450),
invcdf(seq(0,1,length=500))))
samps<-c(seq(0,0.15,length=2050),
seq(0.15,0.25,length=7000),
seq(0.25,0.40,length=450),
invcdf(seq(0,1,length=500)))
hist(samps)
summary(samps)
d <- data.frame(y=samps)
m <- betamix(y ~ 1 | 1, data = d, k = 2)
mu <- plogis(coef(m)[,1]) # plogis distribution of logistic function # [,1] is intercept
phi <- exp(coef(m)[,2])   # [,2] is phi
a <- mu * phi
b <- (1 - mu) * phi
w <- prior(m$flexmix) # probability of clusters for mixture
d <- data.frame(y=samps[-c(1,length(samps))])
summary(d)
d <- data.frame(y=samps[-c(1,length(samps))])
m <- betamix(y ~ 1 | 1, data = d, k = 2)
mu <- plogis(coef(m)[,1]) # plogis distribution of logistic function # [,1] is intercept
phi <- exp(coef(m)[,2])   # [,2] is phi
a <- mu * phi
b <- (1 - mu) * phi
w <- prior(m$flexmix) # probability of clusters for mixture
sum(w*a/(a+b)) # find posterior mean of mixture
mean(d$y) # compare with mean of data
sum(w*pbeta(q=0.4,shape1=a,shape2=b)) # find desired tail probability of mixture
x<-seq(0,1,by=0.01)
## lines for fitted densities
hist(d$y,freq=FALSE)
lines(x, dbeta(x, shape1 = a[1], shape2 = b[1]),col = hcl(0, 80, 50), lwd = 2)
lines(x, dbeta(x, shape1 = a[2], shape2 = b[2]),col = hcl(240, 80, 50), lwd = 2)
lines(x, w[1]*dbeta(x, shape1 = a[1], shape2 = b[1])+w[2]*dbeta(x, shape1 = a[2], shape2 = b[2]))
reps<-1E6
reps
rm(list = ls())
require(flexmix)
require(betareg)
# CDF for lower triangular portion
invcdf<-function(x){
1 - 0.6*sqrt(1 - x)
}
reps<-1E6
samps<-c(seq(0,0.15,length=reps*0.205),
seq(0.15,0.25,length=reps*0.7),
seq(0.25,0.40,length=reps*0.045),
invcdf(seq(0,1,length=reps*0.05)))
hist(samps)
d <- data.frame(y=samps[-c(1,length(samps))])
#################################################################################################
## Gitting mixtures of beta distributions ######################################################
#################################################################################################
m <- betamix(y ~ 1 | 1, data = d, k = 2)
mu <- plogis(coef(m)[,1]) # plogis distribution of logistic function # [,1] is intercept
phi <- exp(coef(m)[,2])   # [,2] is phi
a <- mu * phi
b <- (1 - mu) * phi
w <- prior(m$flexmix) # probability of clusters for mixture
