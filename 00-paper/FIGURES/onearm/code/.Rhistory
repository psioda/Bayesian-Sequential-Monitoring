cov_seed   <- 070720
cov_data   <- read.csv(file = "03-data-covariates.csv")
n1         <- 100
M          <- 1000   # CHECK HERE
lambda.a   <- 0.0001 # noninformative gamma(lambda.a, lambda.b) prior for baseline hazard
lambda.b   <- 0.0001 # noninformative gamma(lambda.a, lambda.b) prior for baseline hazard
lambda     <- 0.3    # baseline hazard
# change here
dim_beta   <- 1
beta1      <- 1.5    # covariate used to measure compatibility
foreach(idx = 1:nrow(simulation)) %dopar% {
#for(idx in 1:nrow(simulation)){
#for(idx in c(1)){
print(idx)
# load simulation parameters
for(i in 1:ncol(simulation)){
assign(names(simulation)[i], simulation[idx, names(simulation)[i]])
}
# covariates
X1        <- as.matrix(cov_data[,c("X1.cov","X1.trt")])
X0        <- as.matrix((cov_data[,"X0.cov"])[1:n0])
if (sim==1){X0.conf <- (cov_data[,"X0.conf.a"])[1:n0]}
if (sim==2){X0.conf <- (cov_data[,"X0.conf.b"])[1:n0]}
if (sim==3){X0.conf <- (cov_data[,"X0.conf.c"])[1:n0]}
# simulate survival times
datArray1 <- array(data = NA, dim = c(B, n1, ncol(X1) + 3)) # 3 columns for id, time, status
datArray0 <- array(data = NA, dim = c(B, n0, ncol(X0) + 3)) # 3 columns for id, time, status
for(b in 1:B){
result1        <- as.matrix(simExp(N = n1, X = X1, lambda = lambda, beta = c(beta1, gamma)))
datArray1[b,,] <- result1
result0        <- as.matrix(simExp(N = n0, X = cbind(X0,X0.conf), lambda = lambda, beta = c(beta1, -0.5*const))) # 6-6-2020
result0        <- result0[,1:(ncol(X0) + 3)] # leaves off confounder covariate
datArray0[b,,] <- result0
}
# compute subject specific discounting parameters
if (compute_a0){
a0         <- matrix(NA, nrow = B, ncol = n0)
for (b in 1:B){
print(paste0(idx, " ", b))
data         <- datArray1[b,,]
theta.tilde  <- predDistSamp(data)   # includes nrow = M
data0        <- data.frame(datArray0[b,,])
names(data0) <- c("id", "time", "status", "X")
for (j in 1:n0){
if (a0_version==4){
#a0[b,j]   <- 0.5
#a0[b,j]    <- runif(1)
a0[b,j]    <- runif(1,0.7,0.8)
}
if (a0_version==3){
time    <- rexp(n = M, rate = theta.tilde[,1]*exp(X0[j]*theta.tilde[,2]))
u <- NA
for (m in 1:M){
u[m] = mean(pexp(q = time[m], rate = theta.tilde[,1]*exp(X0[j]*theta.tilde[,2])))
}
a0[b,j] <- mean(dnorm(qnorm(u)) <= dnorm(qnorm(pexp(q = data0[j,2], rate = theta.tilde[,1]*exp(X0[j]*theta.tilde[,2])))))
}
if (a0_version==2){
time    <- rexp(n = M, rate = theta.tilde[,1]*exp(X0[j]*theta.tilde[,2]))
test    <- pexp(time,  rate = theta.tilde[,1]*exp(X0[j]*theta.tilde[,2]))
fhat2   <- kde(x = qnorm(test))
a0[b,j] <- mean(predict(fhat2, x = qnorm(pmin(test,1 - 1E-16))) <= predict(fhat2, x = qnorm(min(pexp(data0[j,2], rate = lambda*exp(X0[j]*beta1)), 1 - 1E-16))))
}
if (a0_version==1){
step5a  <- simExp(N = M, X  = X0[j], lambda = theta.tilde[,1], beta = theta.tilde[,2])
fhat    <- kde(x=log(step5a[,2]))
a0[b,j] <- mean(predict(fhat,x=log(step5a[,2]))<=predict(fhat,x=log(data0[j,2])))
}
}
}
write.csv(a0, paste0("output/data/sim", idx, ".csv"))
}
# power prior analysis
if (compute_regression){
a0    <- as.matrix(read.csv(paste0("output/data/sim", idx, ".csv"))[,-1])
# loop over analysis methods
analysis_methods <- c(9, seq(0,1,by=0.25)) # 9 for case-specific
for (j in 1:(length(analysis_methods))){
print(paste0("Analysis method ", analysis_methods[j]))
results      <- matrix(NA, nrow = B, ncol = 4)
results_glm  <- matrix(NA, nrow = B, ncol = 2*dim_beta)
for (b in 1:B){
data1        <- data.frame(datArray1[b,,])
names(data1) <- c("id", "time", "status", "X", "Z")
data1.r      <- cbind(data1, type = 1,  a0 = 1)
data0        <- data.frame(datArray0[b,,])
names(data0) <- c("id", "time", "status", "X")
if (analysis_methods[j] ==9){data0.r <- cbind(data0, Z=0, type = 0, a0 = a0[b,])}
else                        {data0.r <- cbind(data0, Z=0, type = 0, a0 = analysis_methods[j])}
data.all        <- rbind(data1.r, data0.r)
results[b,]     <- postDistSamp(data.all)
results_glm[b,] <- logLinear(data.all)
}
write.csv(results,     paste0("output/data/result",     idx, "_", analysis_methods[j], ".csv"))
write.csv(results_glm, paste0("output/data/glm/result", idx, "_", analysis_methods[j], ".csv"))
}
}
}
end_time  <- Sys.time()
diff_time <- difftime(end_time, start_time, units = "auto")
cat("Started  ", as.character(start_time), "\n",
"Finished ", as.character(end_time), "\n",
"Time difference of ", diff_time, " ", attr(diff_time, "units"), "\n",
"Used ", foreach::getDoParWorkers(), " cores\n",
"Used ", foreach::getDoParName(), " as backend\n",
sep = "")
source("05A-output-xtables.R")
source("05B-output-boxplots.R")
rm(list=ls())
start_time <- Sys.time()
setwd("/Users/kwiatkoe/Documents/GitHub/hybrid-methods/pprior-a0j")
compute_a0         <- TRUE
compute_regression <- TRUE
no_covariates      <- TRUE
a0_version         <- 1
library(foreach)
library(doParallel)
registerDoParallel(detectCores())
getDoParWorkers()
library(ks)
source("01A-fcn-simExp.R")
source("01B-fcn-predDistSamp.R")
source("01C-fcn-postDistSamp.R")
source("01D-fcn-logLinear.R")
simulation <- read.csv(file = "02-args-simulation.csv", header = TRUE, sep = ",")
cov_seed   <- 070720
cov_data   <- read.csv(file = "03-data-covariates.csv")
n1         <- 100
M          <- 1000   # CHECK HERE
lambda.a   <- 0.0001 # noninformative gamma(lambda.a, lambda.b) prior for baseline hazard
lambda.b   <- 0.0001 # noninformative gamma(lambda.a, lambda.b) prior for baseline hazard
lambda     <- 0.3    # baseline hazard
# change here
dim_beta   <- 1
beta1      <- 1.5    # covariate used to measure compatibility
foreach(idx = 1:nrow(simulation)) %dopar% {
#for(idx in 1:nrow(simulation)){
#for(idx in c(1)){
print(idx)
# load simulation parameters
for(i in 1:ncol(simulation)){
assign(names(simulation)[i], simulation[idx, names(simulation)[i]])
}
# covariates
X1        <- as.matrix(cov_data[,c("X1.cov","X1.trt")])
X0        <- as.matrix((cov_data[,"X0.cov"])[1:n0])
if (sim==1){X0.conf <- (cov_data[,"X0.conf.a"])[1:n0]}
if (sim==2){X0.conf <- (cov_data[,"X0.conf.b"])[1:n0]}
if (sim==3){X0.conf <- (cov_data[,"X0.conf.c"])[1:n0]}
# simulate survival times
datArray1 <- array(data = NA, dim = c(B, n1, ncol(X1) + 3)) # 3 columns for id, time, status
datArray0 <- array(data = NA, dim = c(B, n0, ncol(X0) + 3)) # 3 columns for id, time, status
for(b in 1:B){
result1        <- as.matrix(simExp(N = n1, X = X1, lambda = lambda, beta = c(beta1, gamma)))
datArray1[b,,] <- result1
result0        <- as.matrix(simExp(N = n0, X = cbind(X0,X0.conf), lambda = lambda, beta = c(beta1, -0.5*const))) # 6-6-2020
result0        <- result0[,1:(ncol(X0) + 3)] # leaves off confounder covariate
datArray0[b,,] <- result0
}
# compute subject specific discounting parameters
if (compute_a0){
a0         <- matrix(NA, nrow = B, ncol = n0)
for (b in 1:B){
print(paste0(idx, " ", b))
data         <- datArray1[b,,]
theta.tilde  <- predDistSamp(data)   # includes nrow = M
data0        <- data.frame(datArray0[b,,])
names(data0) <- c("id", "time", "status", "X")
for (j in 1:n0){
if (a0_version==4){
#a0[b,j]   <- 0.5
#a0[b,j]    <- runif(1)
a0[b,j]    <- runif(1,0.7,0.8)
}
if (a0_version==3){
time    <- rexp(n = M, rate = theta.tilde[,1]*exp(X0[j]*theta.tilde[,2]))
u <- NA
for (m in 1:M){
u[m] = mean(pexp(q = time[m], rate = theta.tilde[,1]*exp(X0[j]*theta.tilde[,2])))
}
a0[b,j] <- mean(dnorm(qnorm(u)) <= dnorm(qnorm(pexp(q = data0[j,2], rate = theta.tilde[,1]*exp(X0[j]*theta.tilde[,2])))))
}
if (a0_version==2){
time    <- rexp(n = M, rate = theta.tilde[,1]*exp(X0[j]*theta.tilde[,2]))
test    <- pexp(time,  rate = theta.tilde[,1]*exp(X0[j]*theta.tilde[,2]))
fhat2   <- kde(x = qnorm(test))
a0[b,j] <- mean(predict(fhat2, x = qnorm(pmin(test,1 - 1E-16))) <= predict(fhat2, x = qnorm(min(pexp(data0[j,2], rate = lambda*exp(X0[j]*beta1)), 1 - 1E-16))))
}
if (a0_version==1){
step5a  <- simExp(N = M, X  = X0[j], lambda = theta.tilde[,1], beta = theta.tilde[,2])
fhat    <- kde(x=log(step5a[,2]))
a0[b,j] <- mean(predict(fhat,x=log(step5a[,2]))<=predict(fhat,x=log(data0[j,2])))
}
}
}
write.csv(a0, paste0("output/data/sim", idx, ".csv"))
}
# power prior analysis
if (compute_regression){
a0    <- as.matrix(read.csv(paste0("output/data/sim", idx, ".csv"))[,-1])
# loop over analysis methods
analysis_methods <- c(9, seq(0,1,by=0.25)) # 9 for case-specific
for (j in 1:(length(analysis_methods))){
print(paste0("Analysis method ", analysis_methods[j]))
results      <- matrix(NA, nrow = B, ncol = 4)
results_glm  <- matrix(NA, nrow = B, ncol = 2*dim_beta)
for (b in 1:B){
data1        <- data.frame(datArray1[b,,])
names(data1) <- c("id", "time", "status", "X", "Z")
data1.r      <- cbind(data1, type = 1,  a0 = 1)
data0        <- data.frame(datArray0[b,,])
names(data0) <- c("id", "time", "status", "X")
if (analysis_methods[j] ==9){data0.r <- cbind(data0, Z=0, type = 0, a0 = a0[b,])}
else                        {data0.r <- cbind(data0, Z=0, type = 0, a0 = analysis_methods[j])}
data.all        <- rbind(data1.r, data0.r)
results[b,]     <- postDistSamp(data.all)
results_glm[b,] <- logLinear(data.all)
}
write.csv(results,     paste0("output/data/result",     idx, "_", analysis_methods[j], ".csv"))
write.csv(results_glm, paste0("output/data/glm/result", idx, "_", analysis_methods[j], ".csv"))
}
}
}
end_time  <- Sys.time()
diff_time <- difftime(end_time, start_time, units = "auto")
cat("Started  ", as.character(start_time), "\n",
"Finished ", as.character(end_time), "\n",
"Time difference of ", diff_time, " ", attr(diff_time, "units"), "\n",
"Used ", foreach::getDoParWorkers(), " cores\n",
"Used ", foreach::getDoParName(), " as backend\n",
sep = "")
source("05A-output-xtables.R")
source("05B-output-boxplots.R")
rm(list=ls())
setwd("/Users/kwiatkoe/Documents/GitHub/hybrid-methods/pprior-a0j")
library(stringi)
library(xtable)
overall_list         <- list.files("output/data/")
results_list         <- overall_list[grepl("result", overall_list, fixed = TRUE)]
idx_list             <- as.numeric(stri_extract_first(results_list, regex="\\d+"))
analysis_method_list <- as.numeric(stri_extract_last(results_list, regex="\\d+"))
simulation           <- read.csv(file = "02-args-simulation.csv", header = TRUE, sep = ",")
sim.vec              <- unique(simulation$sim)
const.vec            <- unique(simulation$const)
summary_mat <- matrix(NA, nrow = length(results_list), ncol = 8)
for (i in 1:length(results_list)){
outer                     <- read.csv(file = paste0("output/data/", results_list[i]), header = TRUE, sep = ",")
summary_mat[i,1]          <- mean(exp(outer[,3])) # HR, 6/15/20
# get generating value of gamma from idx_list
# simulation[idx_list[i],"gamma"]
# change to MSE, used to be SD: mean(sqrt(outer[,5]))
summary_mat[i,2]          <- mean((exp(outer[,3])-exp(simulation[idx_list[i],"gamma"]))^2)
# column1 is ID,
# column2 is hat(beta)
# column3 is hat(gamma)
# column4 is var(beta)
# column5 is var(gamma)
summary_mat[i,3]          <- mean(pnorm(0, mean = outer[,3], sd = sqrt(outer[,5])) > 0.975)
# mean(pnorm((0-outer[,3])/sqrt(outer[,5]))>0.975) # power
summary_mat[i,4]          <- c(simulation[idx_list[i],2])
summary_mat[i,c(5,6,7)]   <- as.numeric(simulation[idx_list[i],c(3,4,5)])
summary_mat[i,8]          <- analysis_method_list[i]
}
summary_mat
summary_mat        <- data.frame(summary_mat)
names(summary_mat) <- c("est", "se", "power", "sim", "n0", "gamma", "const", "analysis")
for (i in 1:nrow(summary_mat)){
if (summary_mat[i,"analysis"] == 9) {summary_mat[i,"analysis"] = 999}
if (summary_mat[i,"analysis"] == 5) {summary_mat[i,"analysis"] = 50}
if (summary_mat[i,"analysis"] == 1) {summary_mat[i,"analysis"] = 100}
}
summary_mat       <- data.frame(as.matrix(summary_mat))
i                 <- 1:8
summary_mat[ , i] <- apply(summary_mat[ , i], 2, function(x) as.numeric(as.character(x)))
summary_mat
sum_mat_sort      <- summary_mat[with(summary_mat, order(-gamma, sim, const, n0, analysis)), ]
sum_mat_sort      <- sum_mat_sort[sum_mat_sort$gamma %in% c(0,-0.5), ]
sum_mat_sort2     <- cbind(sum_mat_sort[(sum_mat_sort[,"gamma"]==0),],sum_mat_sort[(sum_mat_sort[,"gamma"]== -0.5),])
addtorow         <- list()
addtorow$pos     <- list(0)
addtorow$command <- paste0('\\multicolumn{2}{c}{} & \\multicolumn{3}{c}{$\\text{HR}=1$} & \\multicolumn{3}{c}{$\\text{HR}=0.6065$}   \\\\ \\cline{3-5} \\cline{6-8}
$n_0$ & $a_{0j}$ & $\\hat{\\text{HR}}$ & MSE & T1E & $\\hat{\\text{HR}}$ & MSE & Power \\\\')
sum_mat_sort2
for (i in 1:length(sim.vec)){
for (j in 1:length(const.vec)){
table <- sum_mat_sort2[sum_mat_sort2$sim == sim.vec[i] & sum_mat_sort2$const == const.vec[j],]
table <- table[,c(1:16)]
table <- table[,c("n0","analysis","est","se","power","est.1","se.1","power.1")]
table$analysis<-table$analysis/100 # 06-12-2020
for (k in 1:nrow(table)){
if (table$analysis[k]==9.99) {table$analysis[k]="Adaptive"}
if (k%%6!=1) {table$n0[k]=""}
}
if (i==1) title_string <- c("1 (homogeneous external controls)")
if (i==2) title_string <- paste0("2 (unobserved binary covariate effect $X_2\\beta_2$ by setting $\\beta_2=c\\cdot(-0.5)$ for 40\\% of external controls) with c=",const.vec[j])
if (i==3) title_string <- paste0("3 (unobserved continuous covariate effect $X_2\\beta_2$ by setting $\\beta_2=c\\cdot(-0.5)$ for 40\\% of external controls with $X_2\\sim N(0,1))$ with c=",const.vec[j])
print(xtable(table, digits = c(rep(0,3),rep(4,6)), type = "latex",
caption = paste0("Operating characteristics for Design ", title_string,  " by historical sample size $n_0$ and power prior weight $a_0$.")),
include.rownames=FALSE,
include.colnames = FALSE,
caption.placement = "top",
sanitize.text.function=function(x){x},
add.to.row=addtorow)
}
}
merged <- rbind(M1,M2,M3)
rm(list = ls())
library(stringi)
library(xtable)
root<-"/Users/kwiatkoe/Documents/GitHub/Bayesian-Sequential-Monitoring/00-paper/FIGURES/onearm/code"
setwd(root)
source("args_model.R")
args_simulation<-read.csv(file="args_simulation.csv",header=TRUE,sep=",")
## load data from longleaf
Table1    <- read.csv(file="../output/Table1_merged.csv",header=TRUE,sep=",")
combined1 <- merge(args_simulation,Table1,by.x="X",by.y="idx")
combined1      <- combined1[(combined1$model==1 & combined1$p.range %in% c(0.4, 0.535, 0.67)),]
combined1$comb <- NA
combined1$comb[(combined1$skpt_spike==0 & combined1$enth_flat==0)] = 1
combined1$comb[(combined1$skpt_spike==1 & combined1$enth_flat==0)] = 2
combined1$comb[(combined1$skpt_spike==0 & combined1$enth_flat==1)] = 3
combined1$comb[(combined1$skpt_spike==1 & combined1$enth_flat==1)] = 4
combined1 <- combined1[,c("p.range","comb","fut.mon.initial","fut.mon.final","ss.initial")]
M1        <- data.frame(t(combined1[combined1$p.range==0.4,]))
names(M1) <- M1["comb",]
M1$prob   <- M1[1,1]
M1        <- M1[!row.names(M1) %in% c("p.range","comb"),]
M2        <- data.frame(t(combined1[combined1$p.range==0.535,]))
names(M2) <- M2["comb",]
M2$prob   <- M2[1,1]
M2        <- M2[!row.names(M2) %in% c("p.range","comb"),]
M3        <- data.frame(t(combined1[combined1$p.range==0.67,]))
names(M3) <- M3["comb",]
M3$prob   <- M3[1,1]
M3        <- M3[!row.names(M3) %in% c("p.range","comb"),]
merged <- rbind(M1,M2,M3)
names(merged)
merged <- merged[with(merged, order(prob, 1, 2, 3, 4))]
merged <- merged[with(merged, order(prob, 1, 2, 3, 4)),]
merged <- merged[with(merged)]
names(merged)
merged <- merged[with(merged,order(names(merged)))]
merged
names(merged)
merged <- merged[with(merged,order(1, 2, 3, 4, prob)),]
merged <- merged[with(merged, order(names(merged)))]
merged <- merged[with(merged, order(c("prob","1","2","3","4")))]
merged
merged <- merged[with(merged, order(c("prob","1","2","3","4")))]
merged
merged <- merged[with(merged, order(c("prob","1","2","3","4")))]
merged <- merged[with(merged, order(c("prob","1","2","3","4")))]
merged
merged <- merged[with(merged, order(c("prob","1","2","3","4")))]
merged
merged <- merged[with(merged, order(c("prob","1","2","3","4"))),]
merged
merged <- merged[with(merged, order(c("prob","1","2","3","4"))),]
merged
rm(list = ls())
library(stringi)
library(xtable)
root<-"/Users/kwiatkoe/Documents/GitHub/Bayesian-Sequential-Monitoring/00-paper/FIGURES/onearm/code"
setwd(root)
source("args_model.R")
args_simulation<-read.csv(file="args_simulation.csv",header=TRUE,sep=",")
## load data from longleaf
Table1    <- read.csv(file="../output/Table1_merged.csv",header=TRUE,sep=",")
combined1 <- merge(args_simulation,Table1,by.x="X",by.y="idx")
combined1      <- combined1[(combined1$model==1 & combined1$p.range %in% c(0.4, 0.535, 0.67)),]
combined1$comb <- NA
combined1$comb[(combined1$skpt_spike==0 & combined1$enth_flat==0)] = 1
combined1$comb[(combined1$skpt_spike==1 & combined1$enth_flat==0)] = 2
combined1$comb[(combined1$skpt_spike==0 & combined1$enth_flat==1)] = 3
combined1$comb[(combined1$skpt_spike==1 & combined1$enth_flat==1)] = 4
combined1 <- combined1[,c("p.range","comb","fut.mon.initial","fut.mon.final","ss.initial")]
M1        <- data.frame(t(combined1[combined1$p.range==0.4,]))
names(M1) <- M1["comb",]
M1$prob   <- M1[1,1]
M1        <- M1[!row.names(M1) %in% c("p.range","comb"),]
M2        <- data.frame(t(combined1[combined1$p.range==0.535,]))
names(M2) <- M2["comb",]
M2$prob   <- M2[1,1]
M2        <- M2[!row.names(M2) %in% c("p.range","comb"),]
M3        <- data.frame(t(combined1[combined1$p.range==0.67,]))
names(M3) <- M3["comb",]
M3$prob   <- M3[1,1]
M3        <- M3[!row.names(M3) %in% c("p.range","comb"),]
merged <- rbind(M1,M2,M3)
merged <- merged[with(merged, order(c("prob","1","2","3","4"))),]
merged
merged <- merged[c("prob","1","2","3","4")]
merged
rm(list = ls())
library(stringi)
library(xtable)
root<-"/Users/kwiatkoe/Documents/GitHub/Bayesian-Sequential-Monitoring/00-paper/FIGURES/onearm/code"
setwd(root)
source("args_model.R")
args_simulation<-read.csv(file="args_simulation.csv",header=TRUE,sep=",")
## load data from longleaf
Table1    <- read.csv(file="../output/Table1_merged.csv",header=TRUE,sep=",")
combined1 <- merge(args_simulation,Table1,by.x="X",by.y="idx")
combined1      <- combined1[(combined1$model==1 & combined1$p.range %in% c(0.4, 0.535, 0.67)),]
combined1$comb <- NA
combined1$comb[(combined1$skpt_spike==0 & combined1$enth_flat==0)] = 1
combined1$comb[(combined1$skpt_spike==1 & combined1$enth_flat==0)] = 2
combined1$comb[(combined1$skpt_spike==0 & combined1$enth_flat==1)] = 3
combined1$comb[(combined1$skpt_spike==1 & combined1$enth_flat==1)] = 4
combined1 <- combined1[,c("p.range","comb","fut.mon.initial","fut.mon.final","ss.initial")]
M1        <- data.frame(t(combined1[combined1$p.range==0.4,]))
names(M1) <- M1["comb",]
M1$prob   <- M1[1,1]
M1        <- M1[!row.names(M1) %in% c("p.range","comb"),]
M2        <- data.frame(t(combined1[combined1$p.range==0.535,]))
names(M2) <- M2["comb",]
M2$prob   <- M2[1,1]
M2        <- M2[!row.names(M2) %in% c("p.range","comb"),]
M3        <- data.frame(t(combined1[combined1$p.range==0.67,]))
names(M3) <- M3["comb",]
M3$prob   <- M3[1,1]
M3        <- M3[!row.names(M3) %in% c("p.range","comb"),]
merged <- rbind(M1,M2,M3)
merged
colnames(merged)
names(merged)
merged <- merged[,c("prob","1","2","3","4")]
merged
M3
merged
for (i in 1:nrow(merged)){
if (i%%nrow(M1)!=1) {merged$prob[i]=""}
}
merged
merged    <- rbind(M1,M2,M3)
mered$col <- row.names(merged)
merged    <- merged[,c("prob","1","2","3","4")]
merged     <- rbind(M1,M2,M3)
merged$col <- row.names(merged)
merged     <- merged[,c("prob","1","2","3","4")]
merged
row.names(merged)
merged$col <- 1
merged
merged$col <- row.names(merged)
merged
merged     <- rbind(M1,M2,M3)
merged$col <- row.names(merged)
merged
merged     <- merged[,c("prob","col","1","2","3","4")]
for (i in 1:nrow(merged)){
if (i%%nrow(M1)!=1) {merged$prob[i]=""}
}
merged
for (i in 1:nrow(merged)){
if (i%%nrow(M1)!=1) {merged$prob[i]=""}
if (merged$col[i]=="fut.mon.initial") {merged$col[i]="FUT INITIAL"}
if (merged$col[i]=="fut.mon.final") {merged$col[i]="FUT FINAL"}
if (merged$col[i]=="ss.initial") {merged$col[i]="SS"}
}
merged
gsub('[[:digit:]]+', '', "evan2")
for (i in 1:nrow(merged)){
if (i%%nrow(M1)!=1) {merged$prob[i]=""}
if (gsub('[[:digit:]]+', '', merged$col[i])=="fut.mon.initial") {merged$col[i]="FUT INITIAL"}
if (gsub('[[:digit:]]+', '', merged$col[i])=="fut.mon.final") {merged$col[i]="FUT FINAL"}
if (gsub('[[:digit:]]+', '', merged$col[i])=="ss.initial") {merged$col[i]="SS"}
}
merged
print(xtable(table, digits = c(rep(0,3),rep(4,6)), type = "latex"),
include.rownames=FALSE,
include.colnames = FALSE,
caption.placement = "top",
sanitize.text.function=function(x){x})
print(xtable(merged, digits = c(rep(0,3),rep(4,6)), type = "latex"),
include.rownames=FALSE,
include.colnames = FALSE,
caption.placement = "top",
sanitize.text.function=function(x){x})
print(xtable(table, digits = c(rep(0,2),rep(4,4)), type = "latex",
caption = paste0("Operating characteristics for Design ", title_string,  " by historical sample size $n_0$ and power prior weight $a_0$.")),
include.rownames=FALSE,
include.colnames = FALSE,
file = paste0("output/xtables/sim", sim.vec[i], "-const", gsub("[.]","",const.vec[j]), ".tex"),
caption.placement = "top",
sanitize.text.function=function(x){x},
add.to.row=addtorow)
print(xtable(merged, digits = c(rep(0,2),rep(4,4)), type = "latex"),
include.rownames=FALSE,
include.colnames = FALSE,
caption.placement = "top",
sanitize.text.function=function(x){x})
mered
merged
merged
print(xtable(merged, digits = c(rep(0,2),rep(4,4)), type = "latex"),
include.rownames=FALSE,
include.colnames = FALSE,
caption.placement = "top",
sanitize.text.function=function(x){x})
print(xtable(merged, digits = c(rep(0,3),rep(4,4)), type = "latex"),
include.rownames=FALSE,
include.colnames = FALSE,
caption.placement = "top",
sanitize.text.function=function(x){x})
getwd()
print(xtable(merged, digits = c(rep(0,3),rep(4,4)), type = "latex"),
include.rownames=FALSE,
include.colnames = FALSE,
caption.placement = "top",
file = paste0("../../4comparison.tex"),
sanitize.text.function=function(x){x})
