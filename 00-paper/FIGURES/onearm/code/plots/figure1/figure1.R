rm(list = ls())
enth_prior_default<-function(){
  
  mu0.enth<-p.enth
  sigma0.seq<-seq(.01,0.5,by=0.0001)
  lambda0.enth<-2
  
  result<-NA
  
  for (i in 1:length(sigma0.seq)){
    
    sigma0.enth<-sigma0.seq[i]
    
    prior.enth<-function(x){
      exp(-(abs(x-mu0.enth)/sigma0.enth)^lambda0.enth)
    }
    nc.enth<-integrate(prior.enth,lower=-Inf,upper=Inf)[[1]]
    prior.nc.enth<-function(x){
      exp(-(abs(x-mu0.enth)/sigma0.enth)^lambda0.enth)/nc.enth
    }
    
    result[i]<-integrate(prior.nc.enth,lower=-Inf,upper=p.skpt)[[1]]
  }
  
  i<-which(abs(result-tail.enth)==min(abs(result-tail.enth)))
  sigma0.enth<-sigma0.seq[i]
  
  prior.enth<-function(x){
    exp(-(abs(x-mu0.enth)/sigma0.enth)^lambda0.enth)
  }
  nc.enth<-integrate(prior.enth,lower=-Inf,upper=Inf)[[1]]
  prior.nc.enth<-function(x){
    exp(-(abs(x-mu0.enth)/sigma0.enth)^lambda0.enth)/nc.enth
  }
  
  print(paste0("mu: ",mu0.enth,", sigma: ",sigma0.enth,", lambda: ",lambda0.enth))
  print(paste0("Tail area: ",result[i]))
  print(paste0("Half-width area: ",
               integrate(prior.nc.enth,lower=p.skpt,upper=p.intr)[[1]]))
  
  assign("mu0.enth",mu0.enth,envir = .GlobalEnv)
  assign("sigma0.enth",sigma0.enth,envir = .GlobalEnv)
  assign("lambda0.enth",lambda0.enth,envir = .GlobalEnv)
  
  return(prior.nc.enth)
}

enth_prior_custom<-function(scale){
  
  mu0.enth<-p.enth
  sigma0.seq<-seq(.01,0.5,by=0.01)
  lambda0.seq<-seq(1,7,by=0.1)
  result1<-matrix(NA,nrow=length(sigma0.seq),ncol=length(lambda0.seq))
  result2<-matrix(NA,nrow=length(sigma0.seq),ncol=length(lambda0.seq))
  
  for (i in 1:length(sigma0.seq)){
    for (j in 1:length(lambda0.seq)){
      
      sigma0.enth<-sigma0.seq[i]
      lambda0.enth<-lambda0.seq[j]
      
      prior.enth<-function(x){
        exp(-(abs(x-mu0.enth)/sigma0.enth)^lambda0.enth)
      }
      nc.enth<-integrate(prior.enth,lower=-Inf,upper=Inf)[[1]]
      prior.nc.enth<-function(x){
        exp(-(abs(x-mu0.enth)/sigma0.enth)^lambda0.enth)/nc.enth
      }
      
      result1[i,j]<-integrate(prior.nc.enth,lower=-Inf,upper=p.skpt)[[1]]
      result2[i,j]<-integrate(prior.nc.enth,lower=p.skpt,upper=p.intr)[[1]]
    }
  }
  result3=abs(result1-tail.enth)+abs(result2-(pnorm(qnorm(tail.enth)/2)-tail.enth)*scale)
  index<-which(result3 == min(result3), arr.ind = TRUE)
  
  i<-index[1]
  j<-index[2]
  
  sigma0.enth<-sigma0.seq[i]
  lambda0.enth<-lambda0.seq[j]
  
  prior.enth<-function(x){
    exp(-(abs(x-mu0.enth)/sigma0.enth)^lambda0.enth)
  }
  nc.enth<-integrate(prior.enth,lower=0+epsilon,upper=1-epsilon)[[1]]
  prior.nc.enth<-function(x){
    exp(-(abs(x-mu0.enth)/sigma0.enth)^lambda0.enth)/nc.enth
  }
  
  print(paste0("mu: ",mu0.enth,", sigma: ",sigma0.enth,", lambda: ",lambda0.enth))
  print(paste0("Tail area: ",result1[i,j]))
  print(paste0("Half-width area: ",result2[i,j]))
  
  assign("mu0.enth",mu0.enth,envir = .GlobalEnv)
  assign("sigma0.enth",sigma0.enth,envir = .GlobalEnv)
  assign("lambda0.enth",lambda0.enth,envir = .GlobalEnv)
  assign("tail.enth.actual",result1[i,j],envir = .GlobalEnv)
  
  return(prior.nc.enth)
}

p.skpt<-0.40     # response rate for skeptic, enthusiast, futility
p.enth<-0.67
p.intr<-(p.skpt+p.enth)/2
tail.skpt<-0.025  # tail probabilities for priors
tail.enth<-0.025
cred.tail<-0.05
sig.fut<-0.975
sig.eff<-0.975
epsilon<-0 # used to stop numerical error from integration
max.ss<-112
reps<-100000

mu0.skpt<-p.skpt
mu0.enth<-p.enth

#rm(list = ls())
#root<-"P:/Bayesian-Sequential-Monitoring/00-paper/FIGURES/onearm/code"
#setwd(root)

width.scale<-6
png('figure1a.png',width = 300*width.scale, height = 300*width.scale,pointsize=12,res=300)
scale <- 1
prior.nc.enth<-enth_prior_default()

xmin <- p.enth - 0.5
xmax <- p.enth + 0.5
ymax <- 6
x<-seq(xmin,
       xmax,
       by=0.005)
plot(x,prior.nc.enth(x),type="l",
     xlab="",
     ylab="",
     main="",
     xaxt="n",
     yaxt="n",
     xlim=c(xmin,xmax),
     ylim=c(0,ymax)) # 20-01-02
#axis(2,at=c(0,1,2,3),labels=c(0,1,2,3))
axis(1,at=c(p.enth,p.skpt,(p.enth+p.skpt)/2),
     labels=c(as.expression(bquote(theta[1])),
              as.expression(bquote(theta[0])),
              as.expression(bquote((theta[0]+theta[1])/2))))
title(ylab="Density Value", line=1)
title(xlab="Response Probability",line=2)
#title(xlab="Density Value",line=2)

polygon(c(x[x<=p.skpt],p.skpt),
        c(prior.nc.enth(x)[x<=p.skpt],0),col="black")

polygon(c(p.skpt,x[x>=p.skpt & x<=p.intr],p.intr),
        c(0,prior.nc.enth(x)[x>=p.skpt & x<=p.intr],0),col="lightgrey")

segments(x0=p.enth,y0=0,y1=prior.nc.enth(p.enth))

legend("top",
       legend= c(
                 as.expression(bquote(mode(theta) == theta[1])),
                 as.expression(bquote(P(theta< theta[0])==.(tail.enth))),
                 as.expression(bquote(P(theta %in% (theta[0]*","*(theta[0]+theta[1])/2)==.(round((pnorm(qnorm(tail.enth)/2)-tail.enth)*scale,3)))))#,
                 #as.expression(bquote(GN(mu==theta[1],alpha==.(sigma0.enth),beta==.(lambda0.enth))))
       ))

mtext("(A)",side=2,line=1,at=ymax,las=1)
dev.off()

#rm(list = ls())
#root<-"P:/Bayesian-Sequential-Monitoring/00-paper/FIGURES/onearm/code"
#setwd(root)
width.scale<-6
png('figure1b.png',width = 300*width.scale, height = 300*width.scale,pointsize=12,res=300)
scale <- 0.75
prior.nc.enth<-enth_prior_custom(scale=scale)

xmin <- p.enth - 0.5
xmax <- p.enth + 0.5
ymax <- 6
x<-seq(xmin,
       xmax,
       by=0.005)
plot(x,prior.nc.enth(x),type="l",
     xlab="",
     ylab="",
     main="",
     xaxt="n",
     yaxt="n",
     xlim=c(xmin,xmax),
     ylim=c(0,ymax)) # 20-01-02
#axis(2,at=c(0,1,2,3),labels=c(0,1,2,3))
axis(1,at=c(p.enth,p.skpt,(p.enth+p.skpt)/2),
     labels=c(as.expression(bquote(theta[1])),
              as.expression(bquote(theta[0])),
              as.expression(bquote((theta[0]+theta[1])/2))))
title(ylab="Density Value", line=1)
title(xlab="Response Probability",line=2)
#title(xlab="Density Value",line=2)

polygon(c(x[x<=p.skpt],p.skpt),
        c(prior.nc.enth(x)[x<=p.skpt],0),col="black")

polygon(c(p.skpt,x[x>=p.skpt & x<=p.intr],p.intr),
        c(0,prior.nc.enth(x)[x>=p.skpt & x<=p.intr],0),col="lightgrey")

segments(x0=p.enth,y0=0,y1=prior.nc.enth(p.enth))

legend("top",
       legend= c(
                 as.expression(bquote(mode(theta) == theta[1])),
                 as.expression(bquote(P(theta< theta[0])==.(tail.enth))),
                 as.expression(bquote(P(theta %in% (theta[0]*","*(theta[0]+theta[1])/2)==.(round((pnorm(qnorm(tail.enth)/2)-tail.enth)*scale,3)))))#,
                 #as.expression(bquote(GN(mu==theta[1],alpha==.(sigma0.enth),beta==.(lambda0.enth))))
       ))

mtext("(B)",side=2,line=1,at=ymax,las=1)
dev.off()

#rm(list = ls())
#root<-"P:/Bayesian-Sequential-Monitoring/00-paper/FIGURES/onearm/code"
#setwd(root)
width.scale<-6
png('figure1c.png',width = 300*width.scale, height = 300*width.scale,pointsize=12,res=300)
scale <- 1.5
prior.nc.enth<-enth_prior_custom(scale=scale)

xmin <- p.enth - 0.5
xmax <- p.enth + 0.5
ymax <- 6
x<-seq(xmin,
       xmax,
       by=0.005)
plot(x,prior.nc.enth(x),type="l",
     xlab="",
     ylab="",
     main="",
     xaxt="n",
     yaxt="n",
     xlim=c(xmin,xmax),
     ylim=c(0,ymax)) # 20-01-02
#axis(2,at=c(0,1,2,3),labels=c(0,1,2,3))
axis(1,at=c(p.enth,p.skpt,(p.enth+p.skpt)/2),
     labels=c(as.expression(bquote(theta[1])),
              as.expression(bquote(theta[0])),
              as.expression(bquote((theta[0]+theta[1])/2))))
title(ylab="Density Value", line=1)
title(xlab="Response Probability",line=2)
#title(xlab="Density Value",line=2)

polygon(c(x[x<=p.skpt],p.skpt),
        c(prior.nc.enth(x)[x<=p.skpt],0),col="black")

polygon(c(p.skpt,x[x>=p.skpt & x<=p.intr],p.intr),
        c(0,prior.nc.enth(x)[x>=p.skpt & x<=p.intr],0),col="lightgrey")

segments(x0=p.enth,y0=0,y1=prior.nc.enth(p.enth))

legend("top",
       legend= c(
                 as.expression(bquote(mode(theta) == theta[1])),
                 as.expression(bquote(P(theta< theta[0])==.(tail.enth))),
                 as.expression(bquote(P(theta %in% (theta[0]*","*(theta[0]+theta[1])/2)==.(round((pnorm(qnorm(tail.enth)/2)-tail.enth)*scale,3)))))#,
                 #as.expression(bquote(GN(mu==theta[1],alpha==.(sigma0.enth),beta==.(lambda0.enth))))
                 ))

mtext("(C)",side=2,line=1,at=ymax,las=1)
dev.off()